


NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir /gpfs7kro/gpfslocalsys/nvhpc/20.11/Linux_x86_64/20.11/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /gpfs7kro/gpfslocalsys/nvhpc/20.11/Linux_x86_64/20.11/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 2 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: aatestprog.F90

(    1) PROGRAM TEST
(    2) 
(    3) USE MPL_END_MOD, ONLY : MPL_END
(    4) USE MPL_INIT_MOD, ONLY : MPL_INIT
(    5) USE PARKIND1, ONLY : JPIM, JPRB
(    6) USE MPL_MODULE, ONLY : MPL_BARRIER, MPL_MYRANK, MPL_NPROC
(    7) USE MPL_DATA_MODULE, ONLY : MPL_COMM_OML
(    8) USE YOMHOOK, ONLY : DR_HOOK, LHOOK
(    9) USE SET2PE_MOD, ONLY : SET2PE
(   10) 
(   11) USE XRD_GETOPTIONS
(   12) 
(   13) IMPLICIT NONE
(   14) 
(   15) REAL (KIND=JPRB), PARAMETER :: RPI = 2._JPRB * ASIN (1.0_JPRB)
(   16) REAL (KIND=JPRB), PARAMETER :: DEG2RAD = RPI / 180._JPRB
(   17) 
(   18) INTEGER(KIND=JPIM) :: NMSMAX, NSMAX, NDGLG, NPRGPNS, NPRGPEW, NPRTRW, NPRTRV, NDLON, NPRINTLEV, NTIME
(   19) INTEGER(KIND=JPIM) :: MYPROC, NPROC, NBSETSP
(   20) INTEGER(KIND=JPIM) :: NFLEV
(   21) INTEGER(KIND=JPIM) :: NFLEVG
(   22) INTEGER(KIND=JPIM) :: NSPEC2, NSPEC2G, NGPTOT, NGPTOTG, MYSETV, MYSETW
(   23) INTEGER(KIND=JPIM), ALLOCATABLE :: NLOEN (:) 
(   24) INTEGER(KIND=JPIM), ALLOCATABLE :: IFLDSCH (:) 
(   25) INTEGER(KIND=JPIM), ALLOCATABLE :: IVSETOFF (:)
(   26) INTEGER(KIND=JPIM), POINTER     :: INFD (:), IFLDOFF (:)
(   27) INTEGER(KIND=JPIM), ALLOCATABLE, TARGET :: INFD_ALLVSETS (:,:), IFLDOFF_ALLVSETS (:,:)
(   28) 
(   29) REAL (KIND=JPRB) :: ZTSTEP, TIMEF
(   30) 
(   31) REAL (KIND=JPRB),    ALLOCATABLE :: ZSPBUFL (:,:) 
(   32) REAL (KIND=JPRB),    ALLOCATABLE :: ZSPBUFG (:,:) 
(   33) REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFL (:,:,:) 
(   34) REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFG (:,:) 
(   35) INTEGER (KIND=JPIM), ALLOCATABLE :: NBSETLEV (:) 
(   36) INTEGER (KIND=JPIM), ALLOCATABLE :: IVSET (:) 






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 2

(   37) INTEGER (KIND=JPIM) :: NFLDUA, NFLDSU, IFLD, ILEVG, IGPG, JFLDG1, JFLDG2, IPROC
(   38) INTEGER (KIND=JPIM) :: JSETW, JSETV
(   39) INTEGER (KIND=JPIM) :: IFLDGPG, IFLDSPL
(   40) INTEGER (KIND=JPIM) :: IA, IB
(   41) INTEGER (KIND=JPIM) :: NRGRI (8000)
(   42) INTEGER (KIND=JPIM) :: ITIME
(   43) 
(   44) LOGICAL :: LUSEFLT, LUSERPNM, LKEEPRPNM
(   45) LOGICAL :: LSPLIT, LEQ_REGIONS, LDEBUG, LELAM, LLCHECK
(   46) LOGICAL :: LLHOOK
(   47) 
(   48) #include "setup_trans0.h"
(   49) 
(   50) #include "setup_trans.h"
(   51) #include "trans_inq.h"
(   52) #include "dist_grid.h"
(   53) #include "gath_grid.h"
(   54) #include "gath_spec.h"
(   55) #include "dir_trans.h"
(   56) #include "inv_trans.h"
(   57) 
(   58) #include "esetup_trans.h"
(   59) #include "etrans_inq.h"
(   60) #include "edist_grid.h"
(   61) #include "egath_grid.h"
(   62) #include "egath_spec.h"
(   63) #include "edir_trans.h"
(   64) #include "einv_trans.h"
(   65) 
(   66) #include "mpif.h"
(   67) 
(   68) 
(   69) #include "abor1.intfb.h"
(   70) 
(   71) NAMELIST / NAMAATESTPROG / & 
(   72)   & NFLDUA, NFLDSU, NMSMAX, NSMAX, NDGLG, NFLEVG, LDEBUG, NDLON, NPRINTLEV, NTIME, LELAM
(   73) 
(   74) NAMELIST / NAMTRANS / & 
(   75)   & LUSEFLT, LUSERPNM, LKEEPRPNM
(   76) 
(   77) NAMELIST / NAMPAR0 / & 
(   78)   & NPRGPNS, NPRGPEW, NPRTRW, NPRTRV
(   79) 
(   80) NAMELIST / NAMPAR1 / & 
(   81)   & LEQ_REGIONS, LSPLIT
(   82) 
(   83) NAMELIST / NAMRGRI / & 
(   84)   & NRGRI
(   85) 
(   86) CHARACTER (LEN=64) :: CLNAMELIST
(   87) CHARACTER (LEN=64) :: CLFIELD
(   88) LOGICAL :: LLMPOFF, LLNOWRITE, LLNODIRTRANS, LLNOINVTRANS, LLTESTHARMONICS, LLALLOPERM
(   89) 
(   90) REAL (KIND=JPRB) :: ZHOOK_HANDLE
(   91) 
(   92) !CALL GPU_BIND_JZ
(   93) 
(   94) CALL INITOPTIONS ()






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 3

(   95) CLNAMELIST = 'fort.4'
(   96) CALL GETOPTION ("--namelist", CLNAMELIST)
(   97) CALL GETOPTION ("--lmpoff", LLMPOFF)
(   98) NTIME     = 10
(   99) CALL GETOPTION ("--time", NTIME)
(  100) CLFIELD = ''
(  101) CALL GETOPTION ("--field-file", CLFIELD)
(  102) CALL GETOPTION ("--no-write", LLNOWRITE)
(  103) CALL GETOPTION ("--no-dir-trans", LLNODIRTRANS)
(  104) CALL GETOPTION ("--no-inv-trans", LLNOINVTRANS)
(  105) CALL GETOPTION ("--test-harmonics", LLTESTHARMONICS)
(  106) CALL GETOPTION ("--alloperm", LLALLOPERM)
(  107) CALL GETOPTION ("--check", LLCHECK)
(  108) CALL CHECKOPTIONS ()
(  109) 
(  110) LLHOOK = LHOOK
(  111) LHOOK = .FALSE.
(  112) 
(  113) OPEN (4, FILE=TRIM (CLNAMELIST), FORM='FORMATTED')
(  114) 
(  115) LELAM     = .FALSE.
(  116) NFLDUA    = 1
(  117) NFLDSU    = 0
(  118) NPRINTLEV = 0
(  119) NSMAX     = 0
(  120) NMSMAX    = 0
(  121) NDGLG     = 0
(  122) NFLEVG    = 19
(  123) LDEBUG    = .FALSE.
(  124) 
(  125) CALL POSNAM (4, 'NAMAATESTPROG')
(  126) READ (4, NAMAATESTPROG)
(  127) 
(  128) IF ((NSMAX == 0) .OR. (NDGLG == 0)) THEN
(  129)   CALL ABOR1 ('DWARF: NSMAX AND NDGLG ARE REQUIRED')
(  130) ENDIF
(  131) 
(  132) NPRGPNS = 0 
(  133) NPRGPEW = 0 
(  134) NPRTRW  = 0 
(  135) NPRTRV  = 0 
(  136) 
(  137) CALL POSNAM (4, 'NAMPAR0')
(  138) READ (4, NAMPAR0)
(  139) 
(  140) LUSEFLT   = NSMAX > 1280
(  141) LUSERPNM  = .NOT.LUSEFLT
(  142) LKEEPRPNM = .NOT.LUSEFLT
(  143) 
(  144) CALL POSNAM (4, 'NAMTRANS')
(  145) READ (4, NAMTRANS)
(  146) 
(  147) LEQ_REGIONS = .NOT. LELAM
(  148) LSPLIT      = .TRUE.
(  149) 
(  150) CALL POSNAM (4, 'NAMPAR1')
(  151) READ (4, NAMPAR1)
(  152) 






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 4

(  153) IF (LELAM) THEN
(  154)   NRGRI = NDLON
(  155) ELSE
(  156)   NRGRI = 0
(  157) ENDIF
(  158) 
(  159) CALL POSNAM (4, 'NAMRGRI')
(  160) READ (4, NAMRGRI)
(  161) 
(  162) CLOSE (4)
(  163) 
(  164) ALLOCATE (NLOEN (NDGLG))
(  165) NLOEN (1:NDGLG) = NRGRI (1:NDGLG)
(  166) 
(  167) IF (.NOT. LELAM) THEN
(  168)   IF (ANY (NLOEN (NDGLG/2+1:NDGLG) == 0)) THEN
(  169)     NLOEN (NDGLG/2+1:NDGLG) = NLOEN (NDGLG/2:1:-1)
(  170)   ENDIF
(  171)   IF (ANY (NLOEN (NDGLG/2:1:-1) /= NLOEN (NDGLG/2+1:NDGLG))) THEn
(  172)     CALL ABOR1 ('UNEXPECTED NLOEN')
(  173)   ENDIF
(  174) ENDIF
(  175) 
(  176) IF (LLMPOFF) THEN
(  177)   MYPROC = 1
(  178)   NPROC  = 1
(  179) ELSE
(  180)   CALL MPL_INIT 
(  181)   MYPROC = MPL_MYRANK()
(  182)   NPROC  = MPL_NPROC ()
(  183) ENDIF
(  184) 
(  185) ! GPU binding
(  186) 
(  187) !CALL GPU_BIND (MYPROC-1, NPROC)
(  188) 
(  189) IF (NPROC > 1 .AND. LLTESTHARMONICS) THEN
(  190)   CALL ABOR1 ('NPROC > 1 .AND. LLTESTHARMONICS')
(  191) ENDIF
(  192) 
(  193) CALL SQUARE (NPROC, IB, IA)
(  194) 
(  195) IF (NPRGPNS == 0 .AND. NPRGPEW == 0) THEN
(  196)   NPRGPNS = IA
(  197)   NPRGPEW = IB
(  198) ENDIF
(  199) 
(  200) IF (NPRTRW == 0 .AND. NPRTRV == 0) THEN
(  201)   NPRTRW = IA
(  202)   NPRTRV = IB
(  203) ENDIF
(  204) 
(  205) NBSETSP = MIN (NFLEVG+1, NPRTRV)
(  206) 
(  207) IF (MYPROC == 1) THEN
(  208) 
(  209)   WRITE (0, *) " NPROC = ", NPROC, " NTIME = ", NTIME, " LELAM = ", LELAM
(  210)   WRITE (0, *) " NFLDUA = ", NFLDUA, " NFLDSU = ", NFLDSU, " NFLEVG = ", NFLEVG






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 5

(  211)   WRITE (0, *) " NPRGPNS = ", NPRGPNS, " NPRGPEW = ", NPRGPEW
(  212)   WRITE (0, *) " NPRTRW = ", NPRTRW, " NPRTRV = ", NPRTRV
(  213)   WRITE (0, *) " LEQ_REGIONS = ", LEQ_REGIONS, " LSPLIT = ", LSPLIT
(  214)   WRITE (0, *) " NSMAX = ", NSMAX, " NDGLG = ", NDGLG
(  215) 
(  216) ENDIF
(  217) 
(  218) MYSETV = MOD (MYPROC-1, NPRTRV) + 1
(  219) MYSETW = (MYPROC-1) / NPRTRV + 1
(  220) 
(  221) 
(  222) CALL SETUP_TRANS0 (KOUT=0, KERR=0, KPRINTLEV=NPRINTLEV, KMAX_RESOL=2,   &
(  223)                  & KPRGPNS=NPRGPNS, KPRGPEW=NPRGPEW, KPRTRW=NPRTRW,     &
(  224)                  & LDEQ_REGIONS=LEQ_REGIONS, LDMPOFF=LLMPOFF,           &
(  225)                  & LDALLOPERM=LLALLOPERM)
(  226) IF (LELAM) THEN
(  227)   CALL ESETUP_TRANS (KSMAX=NSMAX, KMSMAX=NMSMAX, KDGL=NDGLG, KDGUX=NDGLG, KLOEN=NLOEN, &
(  228)                    & LDSPLIT=LSPLIT, KFLEV=NFLEVG)
(  229)   CALL ETRANS_INQ (KSPEC2=NSPEC2, KGPTOT=NGPTOT, KSPEC2G=NSPEC2G, KGPTOTG=NGPTOTG)
(  230) ELSE
(  231)   CALL SETUP_TRANS (KSMAX=NSMAX, KDGL=NDGLG, KLOEN=NLOEN, LDSPLIT=LSPLIT, KFLEV=NFLEVG, &
(  232)                   & LDUSEFLT=LUSEFLT,LDUSERPNM=LUSERPNM, LDKEEPRPNM=LKEEPRPNM)
(  233)   CALL TRANS_INQ (KSPEC2=NSPEC2, KGPTOT=NGPTOT, KSPEC2G=NSPEC2G, KGPTOTG=NGPTOTG)
(  234) ENDIF
(  235) 
(  236) IF (MYPROC == 1) THEN
(  237)   WRITE (0, *) " NGPTOTG = ", NGPTOTG, " NSPEC2G = ", NSPEC2G
(  238) ENDIF
(  239) 
(  240) ALLOCATE (NBSETLEV (NFLEVG))
(  241) 
(  242) DO ILEVG = 1, NFLEVG
(  243)   NBSETLEV (ILEVG) = MOD (ILEVG, NPRTRV) + 1
(  244) ENDDO
(  245) 
(  246) NFLEV = COUNT (NBSETLEV == MYSETV)
(  247) 
(  248) IFLDGPG = NFLDSU + NFLDUA * NFLEVG 
(  249) ALLOCATE (IVSET (IFLDGPG))
(  250) 
(  251) DO IFLD = 1, NFLDSU
(  252)   IVSET (IFLD) = NBSETSP
(  253) ENDDO
(  254) 
(  255) DO IFLD = 1, NFLDUA
(  256)   DO ILEVG = 1, NFLEVG
(  257)     IVSET (NFLDSU+ILEVG+(IFLD-1)*NFLEVG) = NBSETLEV (ILEVG)
(  258)   ENDDO
(  259) ENDDO
(  260) 
(  261) IFLDSPL = COUNT (IVSET == MYSETV)
(  262) 
(  263) ALLOCATE (ZSPBUFL (IFLDSPL, NSPEC2))
(  264) ALLOCATE (ZGPBUFL (NGPTOT, IFLDGPG, 1))
(  265) 
(  266) CALL GENFIELD
(  267) 
(  268) 






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 6

(  269) IF (LLCHECK) THEN
(  270)   CALL CHECK (LDDIFF=.FALSE.)
(  271) ENDIF
(  272) 
(  273) IF (.NOT. LLNOWRITE) THEN
(  274)   CALL WRIFIELD ('AATESTPROG.0.fa')
(  275) ENDIF
(  276) 
(  277) IF (.NOT. LLMPOFF) CALL MPL_BARRIER()
(  278) 
(  279) LHOOK = LLHOOK
(  280) 
(  281) IF (LHOOK) CALL DR_HOOK ('AATESTPROG',0,ZHOOK_HANDLE)
(  282) 
(  283) IF (LLTESTHARMONICS) THEN
(  284)   CALL TESTHARMONICS
(  285) ELSE
(  286)   DO ITIME = 1, NTIME
(  287)     ZTSTEP = TIMEF()
(  288)     IF (LELAM) THEN
(  289)       IF (.NOT. LLNODIRTRANS) CALL EDIR_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  290)       IF (.NOT. LLNOINVTRANS) CALL EINV_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  291)     ELSE
(  292)       IF (.NOT. LLNODIRTRANS) CALL DIR_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  293)       IF (.NOT. LLNOINVTRANS) CALL INV_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  294)     ENDIF
(  295)   
(  296)     IF(MYPROC == 1) THEN
(  297)       ZTSTEP=(TIMEF()-ZTSTEP)
(  298)       WRITE(*,'(" time step ",I6," took", F8.2)') ITIME, ZTSTEP
(  299)     ENDIF
(  300)   ENDDO
(  301) ENDIF
(  302) 
(  303) CALL FLUSH (0)
(  304) 
(  305) IF (LELAM) THEN
(  306)   CALL ETRANS_END
(  307) ELSE
(  308)   CALL TRANS_END
(  309) ENDIF
(  310) 
(  311) 999 CONTINUE
(  312) 
(  313) IF (.NOT. LLMPOFF) CALL MPL_BARRIER
(  314) 
(  315) IF (LHOOK) CALL DR_HOOK ('AATESTPROG',1,ZHOOK_HANDLE)
(  316) 
(  317) IF (.NOT. LLNOWRITE) THEN
(  318)   CALL WRIFIELD ('AATESTPROG.1.fa')
(  319) ENDIF
(  320) 
(  321) IF (LLCHECK) THEN
(  322)   CALL CHECK (LDDIFF=.FALSE.)
(  323)   CALL CHECK (LDDIFF=.TRUE.)
(  324) ENDIF
(  325) 
(  326) IF (.NOT. LLMPOFF) CALL MPL_END






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 7

(  327) 
(  328) IF (MYPROC == 1) WRITE (0, *) " --------- END --------- "
(  329) 
(  330) CALL FLUSH (0)
(  331) 
(  332) CONTAINS
(  333) 
(  334) SUBROUTINE TESTHARMONICS
(  335) 
(  336) INTEGER (KIND=JPIM) :: INHARM
(  337) CHARACTER (LEN=32) :: CLFILE
(  338) 
(  339) DO INHARM = 1, NSPEC2G
(  340) 
(  341)   WRITE (CLFILE, '(I6.6)') INHARM
(  342) 
(  343)   ZSPBUFL = 0._JPRB
(  344)   ZSPBUFL (1, INHARM) = 1._JPRB
(  345)   ZGPBUFL = 999._JPRB
(  346) 
(  347)   CALL EINV_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  348)   
(  349) ! OPEN (77, FILE=TRIM (CLFILE)//'.gp.dat')
(  350) ! WRITE (77, *) ZGPBUFL (:, 1, 1)
(  351) ! CLOSE (77)
(  352) 
(  353)   ZSPBUFL = 999._JPRB
(  354) 
(  355)   CALL EDIR_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  356) 
(  357) ! OPEN (77, FILE=TRIM (CLFILE)//'.sp.dat')
(  358) ! WRITE (77, *) ZSPBUFL (1, :)
(  359) ! CLOSE (77)
(  360) 
(  361)   WHERE (ABS (ZSPBUFL) < 1E-15)
(  362)     ZSPBUFL = 0._JPRB
(  363)   ENDWHERE
(  364) 
(  365)   WHERE (ABS (ZSPBUFL - 1._JPRB) < 1E-15)
(  366)     ZSPBUFL = 1._JPRB
(  367)   ENDWHERE
(  368) 
(  369)   WRITE (88, '(I6," ",I6," ",I6," ",I6," ",I6)') INHARM, &
(  370)        & COUNT (ZSPBUFL (1, :) == 0._JPRB), COUNT (ZSPBUFL (1, :) == 1._JPRB), &
(  371)        & COUNT ((ZSPBUFL (1, :) /= 1._JPRB) .AND. (ZSPBUFL (1, :) /= 0._JPRB)), &
(  372)        & NSPEC2G
(  373)  
(  374) 
(  375) ENDDO
(  376) 
(  377) END SUBROUTINE
(  378) 
(  379) SUBROUTINE SQUARE (KN, KA, KB)
(  380) 
(  381) INTEGER (KIND=JPIM) :: KN, KA, KB
(  382) 
(  383) KB = INT (SQRT (REAL (KN))) + 1
(  384) 






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 8

(  385) DO
(  386)   KA = KN / KB
(  387)   IF (KA * KB == KN) EXIT
(  388)   KB = KB - 1
(  389) ENDDO
(  390) 
(  391) END SUBROUTINE SQUARE
(  392) 
(  393) SUBROUTINE POSNAM (KULNAM,CDNAML)
(  394) 
(  395) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  396) USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
(  397) 
(  398) IMPLICIT NONE
(  399) 
(  400) INTEGER(KIND=JPIM),INTENT(IN)    :: KULNAM 
(  401) CHARACTER(LEN=*)  ,INTENT(IN)    :: CDNAML 
(  402) 
(  403) 
(  404) #include "abor1.intfb.h"
(  405) 
(  406) 
(  407) CHARACTER (LEN = 40) ::  CLINE
(  408) CHARACTER (LEN =  1) ::  CLTEST
(  409) 
(  410) INTEGER(KIND=JPIM) :: ILEN, IND1, ISTATUS, ISCAN
(  411) REAL(KIND=JPRB)    :: ZHOOK_HANDLE
(  412) 
(  413) IF (LHOOK) CALL DR_HOOK('POSNAM',0,ZHOOK_HANDLE)
(  414) 
(  415) CLINE='                                        '
(  416) REWIND(KULNAM)
(  417) ILEN=LEN(CDNAML)
(  418) ISTATUS=0
(  419) ISCAN=0
(  420) DO WHILE (ISTATUS==0 .AND. ISCAN==0)
(  421)   READ(KULNAM,'(A)',IOSTAT=ISTATUS) CLINE
(  422)   SELECT CASE (ISTATUS)
(  423)   CASE (:-1)
(  424)     CALL ABOR1 ('POSNAM: CANNOT FIND '//TRIM (CDNAML))
(  425)   CASE (0)
(  426)     IF (INDEX(CLINE(1:10),'&') == 0) THEN
(  427)       ISCAN=0
(  428)     ELSE
(  429)       IND1=INDEX(CLINE,'&'//CDNAML)
(  430)       IF (IND1 == 0) THEN
(  431)         ISCAN=0
(  432)       ELSE
(  433)         CLTEST=CLINE(IND1+ILEN+1:IND1+ILEN+1)
(  434)         IF (   (LGE(CLTEST,'0').AND.LLE(CLTEST,'9')) &
(  435)          & .OR.(LGE(CLTEST,'A').AND.LLE(CLTEST,'Z')) ) THEN
(  436)           ISCAN=0
(  437)         ELSE
(  438)           ISCAN=1
(  439)         ENDIF
(  440)       ENDIF
(  441)     ENDIF
(  442)   CASE (1:)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 9

(  443)     CALL ABOR1 ('POSNAM: AN ERROR HAPPENED WHILE READING THE NAMELIST')
(  444)   END SELECT
(  445) ENDDO
(  446) BACKSPACE(KULNAM)
(  447) 
(  448) IF (LHOOK) CALL DR_HOOK('POSNAM',1,ZHOOK_HANDLE)
(  449) END SUBROUTINE POSNAM
(  450) 
(  451) SUBROUTINE WRIFIELD (CDFILE)
(  452) 
(  453) CHARACTER (LEN=*), INTENT (IN) :: CDFILE
(  454) INTEGER (KIND=JPIM) :: ITO (IFLDGPG), JFLD
(  455) CHARACTER (LEN=16) :: CLPREF, CLSUFF
(  456) 
(  457) ITO = 1
(  458) 
(  459) IF (MYPROC == 1) THEN
(  460)   ALLOCATE (ZGPBUFG (NGPTOTG, IFLDGPG))
(  461) 
(  462)   IF (LELAM) THEN
(  463)     CALL EGATH_GRID (PGPG=ZGPBUFG, KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
(  464)   ELSE
(  465)     CALL GATH_GRID (PGPG=ZGPBUFG, KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
(  466)   ENDIF
(  467) 
(  468)   CALL SYSTEM ('rm -f '//TRIM (CDFILE))
(  469) 
(  470)   DO JFLD = 1, IFLDGPG
(  471)     CLPREF = 'SURF'
(  472)     WRITE (CLSUFF, '("FFFF.",I4.4)') JFLD
(  473)     CALL WFA (ZGPBUFG (:, JFLD), CDFILE, CLPREF, CLSUFF)
(  474)   ENDDO
(  475) 
(  476)   DEALLOCATE (ZGPBUFG)
(  477) ELSE
(  478)   IF (LELAM) THEN
(  479)     CALL EGATH_GRID (KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
(  480)   ELSE
(  481)     CALL GATH_GRID (KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
(  482)   ENDIF
(  483) ENDIF
(  484) 
(  485) END SUBROUTINE
(  486) 
(  487) SUBROUTINE WFA (PGLO, CDFILE, CDPREF, CDSUFF)
(  488) 
(  489) REAL (KIND=JPRB),  INTENT (IN) :: PGLO (:)
(  490) CHARACTER (LEN=*), INTENT (IN) :: CDFILE, CDPREF, CDSUFF
(  491) 
(  492) REAL (KIND=JPRB) :: ZMU (NDGLG)
(  493) 
(  494) CHARACTER (LEN=3) :: CLNOMC 
(  495) REAL (KIND=JPRB) :: ZAHYBR (2), ZBHYBR (2), ZSLAPO, ZCLOPO, ZSLOPO, ZCODIL, ZREFER
(  496) INTEGER (KIND=JPIM) :: INIVER, ITYPTR, ITRONC, INLATI, INXLON
(  497) INTEGER (KIND=JPIM) :: NLOENG (NDGLG), INOZPA (NDGLG)
(  498) INTEGER (KIND=JPIM) :: INBARP, INBARI, ILUN, IREP
(  499) INTEGER (KIND=JPIM) :: INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5
(  500) INTEGER (KIND=JPIM) :: IDATEF (11), ILCHAM






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 10

(  501) CHARACTER (LEN=16)  :: CLSTATUS
(  502) LOGICAL :: LLEXIST
(  503) 
(  504) INQUIRE (FILE=TRIM (CDFILE), EXIST=LLEXIST)
(  505) 
(  506) IF (LLEXIST) THEN
(  507)   CLSTATUS = 'OLD'
(  508)   IF (LELAM) THEN
(  509)     CLNOMC = 'ALD'
(  510)   ELSE
(  511)     CLNOMC = 'ARP'
(  512)   ENDIF
(  513) ELSE
(  514)   CLSTATUS = 'NEW'
(  515) IF (LELAM) THEN
(  516) BLOCK
(  517)   INTEGER (KIND=JPIM) :: INLOPA (8)
(  518)   INTEGER (KIND=JPIM) :: NX, NY, NUX, NUY
(  519)   REAL (KIND=JPRB) :: DXINMETRES, DYINMETRES
(  520)   REAL (KIND=JPRB) :: ZSINLA (18)
(  521) 
(  522)   REAL (KIND=JPRB), PARAMETER :: LADINDEGREES    = 46.2_JPRB
(  523)   REAL (KIND=JPRB), PARAMETER :: LATIN1INDEGREES = 46.2_JPRB
(  524)   REAL (KIND=JPRB), PARAMETER :: LATIN2INDEGREES = 46.2_JPRB
(  525)   REAL (KIND=JPRB), PARAMETER :: LOVINDEGREES    =  2.0_JPRB
(  526) 
(  527)   CLNOMC = 'ALD'
(  528)   NX = NDLON
(  529)   NY = NDGLG
(  530) 
(  531)   ! Round dx to 100m
(  532)   DXINMETRES = 2000.E3_JPRB / REAL (NX - 1, JPRB)
(  533)   DXINMETRES = 100._JPRB * NINT (DXINMETRES / 100._JPRB) 
(  534)   DYINMETRES = DXINMETRES
(  535) 
(  536)   NUX = NX - 1
(  537)   NUY = NY - 1
(  538) 
(  539)   INLATI = NY
(  540)   INXLON = NX
(  541)   ZSLAPO = 0._JPRB
(  542)   ZCLOPO = 0._JPRB
(  543)   ZSLOPO = 0._JPRB
(  544)   ZCODIL = 0._JPRB
(  545)   ZREFER = 0._JPRB
(  546)   INIVER = 1_JPIM
(  547)   ZAHYBR = 0._JPRB
(  548)   ZBHYBR = 0._JPRB 
(  549)   INLOPA = [10_JPIM, 1_JPIM, 1_JPIM, NUX+1, 1_JPIM, NUY+1, 8_JPIM, 8_JPIM]
(  550)   ITRONC = +INLATI / 2 - 1 
(  551)   ITYPTR = -INXLON / 2 + 1 
(  552)   
(  553)   ZSINLA = [-1._JPRB, SIN (DEG2RAD * LADINDEGREES), DEG2RAD * LOVINDEGREES, DEG2RAD * LADINDEGREES, &
(  554)          &  DEG2RAD * LOVINDEGREES, DEG2RAD * LADINDEGREES, DXINMETRES, DYINMETRES, &
(  555)          &  INXLON * DXINMETRES, INLATI * DYINMETRES, 0._JPRB, 0._JPRB, 0._JPRB, &
(  556)          &  0._JPRB, 0._JPRB, 0._JPRB, 0._JPRB, 0._JPRB ]
(  557)   
(  558)   CALL FACADE (CLNOMC, ITYPTR, ZSLAPO, ZCLOPO, ZSLOPO, &






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 11

(  559)   &            ZCODIL, ITRONC, INLATI, INXLON, INLOPA, &
(  560)   &            INOZPA, ZSINLA, INIVER, ZREFER, ZAHYBR, &
(  561)   &            ZBHYBR, .FALSE.)
(  562) 
(  563) ENDBLOCK
(  564) ELSE
(  565) BLOCK
(  566)   REAL (KIND=JPRB) :: ZCENTRE (2)
(  567) 
(  568)   CLNOMC = 'ARP'
(  569) 
(  570)   CALL TRANS_INQ (PMU=ZMU)
(  571)   
(  572)   ZCENTRE = [0._JPRB, 90._JPRB]
(  573)   ZCODIL = 1._JPRB
(  574)   
(  575)   INIVER = 1_JPIM
(  576)   ZAHYBR = 0._JPRB
(  577)   ZBHYBR = 0._JPRB
(  578)   ITYPTR = 2_JPIM
(  579)   
(  580)   NLOENG = NLOEN
(  581)   
(  582)   ZSLAPO = SIN (ZCENTRE (2) * DEG2RAD)
(  583)   ZCLOPO = COS (ZCENTRE (1) * DEG2RAD)
(  584)   ZSLOPO = SIN (ZCENTRE (1) * DEG2RAD)
(  585)   INLATI = NDGLG
(  586)   INXLON = MAXVAL (NLOENG)
(  587)   ITRONC = INXLON / 3
(  588)   INOZPA = MIN (ITRONC, NLOENG/2_JPIM-1_JPIM)
(  589)   ZREFER = 1._JPRB
(  590)   
(  591)   CALL FACADE (CLNOMC, ITYPTR, ZSLAPO, ZCLOPO, ZSLOPO, &
(  592)   &            ZCODIL, ITRONC, INLATI, INXLON, NLOENG, &
(  593)   &            INOZPA, ZMU,    INIVER, ZREFER, ZAHYBR, &
(  594)   &            ZBHYBR, .FALSE.)
(  595) 
(  596) ENDBLOCK
(  597) ENDIF
(  598) ENDIF
(  599)  
(  600) 
(  601) INBARP = 0
(  602) INBARI = 0
(  603) ILUN = 77
(  604) CALL FAITOU (IREP, ILUN, .TRUE., TRIM (CDFILE), CLSTATUS, .TRUE., &
(  605)            & .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)
(  606) 
(  607) IDATEF = [1990,  2, 15, 12,  0,   1,  0, 24,   1, 0, 0]
(  608) CALL FANDAR (IREP, ILUN, IDATEF)
(  609) 
(  610) CALL FATCHA (IREP, CLNOMC, .FALSE., ILCHAM)
(  611) 
(  612) CALL FAVEUR (IREP, ILUN, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)
(  613) INGRIB = 123_JPIM
(  614) CALL FAGOTE (IREP, ILUN, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)
(  615) 
(  616) CALL FAIENC (IREP, ILUN, CDPREF, 0, CDSUFF, PGLO, .FALSE.)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 12

(  617) 
(  618) CALL FAIRME (IREP, ILUN, 'KEEP')
(  619) 
(  620) END SUBROUTINE
(  621) 
(  622) SUBROUTINE CHECK (LDDIFF)
(  623) 
(  624) LOGICAL, INTENT (IN) :: LDDIFF
(  625) 
(  626) ! Save result in ZGPBUFL1
(  627) 
(  628) REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFL1 (:,:,:) 
(  629) REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFG1 (:,:) 
(  630) INTEGER (KIND=JPIM) :: JFLD, ITO (1)
(  631) REAL (KIND=JPRB) :: ZDIFF2 (IFLDGPG)
(  632) 
(  633) ALLOCATE (ZGPBUFL1 (NGPTOT, IFLDGPG, 1)) 
(  634) 
(  635) ZGPBUFL1 = ZGPBUFL
(  636) 
(  637) ! Recreate original field
(  638) 
(  639) 
(  640) IF (LDDIFF) THEN
(  641)   CALL GENFIELD
(  642)   ZGPBUFL1 = ZGPBUFL1 - ZGPBUFL
(  643) ENDIF
(  644) 
(  645) IF (MYPROC == 1) THEN
(  646)   IF (LDDIFF) THEN
(  647)     WRITE (100, *) "                  ------------- DIFF ------------- "
(  648)   ELSE
(  649)     WRITE (100, *) "                  ------------- STAT ------------- "
(  650)   ENDIF
(  651) ENDIF
(  652) 
(  653) ITO = 1
(  654) 
(  655) DO JFLD = 1, IFLDGPG
(  656) 
(  657)   IF (MYPROC == 1) THEN
(  658)     ALLOCATE (ZGPBUFG1 (NGPTOTG, 1))
(  659)     IF (LELAM) THEN
(  660)       CALL EGATH_GRID (PGPG=ZGPBUFG1, KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))
(  661)     ELSE
(  662)       CALL GATH_GRID (PGPG=ZGPBUFG1, KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))
(  663)     ENDIF
(  664)     WRITE (100, '(" FIELD ",I6," L2 =",E16.8," L1 = ",E16.8," MEAN =",E16.8)') & 
(  665)          & JFLD, SQRT (SUM (ZGPBUFG1 * ZGPBUFG1) / REAL (NGPTOTG, JPRB)), &
(  666)          & SUM (ABS (ZGPBUFG1)) / REAL (NGPTOTG, JPRB), SUM (ZGPBUFG1)
(  667)     DEALLOCATE (ZGPBUFG1)
(  668)   ELSE
(  669)     IF (LELAM) THEN
(  670)       CALL EGATH_GRID (KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))
(  671)     ELSE
(  672)       CALL GATH_GRID (KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))
(  673)     ENDIF
(  674)   ENDIF






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 13

(  675) 
(  676) ENDDO
(  677) 
(  678) END SUBROUTINE
(  679) 
(  680) SUBROUTINE GENFIELD
(  681) 
(  682) IF (MYPROC == 1) THEN
(  683)   ALLOCATE (ZGPBUFG (NGPTOTG, 1))
(  684) 
(  685)   IF (CLFIELD /= '') THEN
(  686)     OPEN (77, FILE=TRIM (CLFIELD), FORM='UNFORMATTED', STATUS='OLD')
(  687)     READ (77) ZGPBUFG (:, 1)
(  688)     CLOSE (77)
(  689)   ELSE
(  690)   BLOCK
(  691)     REAL (KIND=JPRB) :: ZLON, ZLAT, ZVAL, ZX, ZY
(  692)     INTEGER (KIND=JPIM) :: JLAT, JLON, JGLO
(  693) 
(  694)     JGLO = 1
(  695) 
(  696)     DO JLAT = 1, NDGLG
(  697)       DO JLON = 1, NLOEN (JLAT)
(  698)        
(  699)         IF (LELAM) THEN
(  700)           ZX = REAL (JLON-1, JPRB) / REAL (NDLON, JPRB)
(  701)           ZY = REAL (JLAT-1, JPRB) / REAL (NDLON, JPRB)
(  702)           ZVAL = ZX * (1._JPRB - ZX) * ZY * (1._JPRB - ZY) * 4._JPRB + 0.5
(  703)         ELSE
(  704)           ZLAT = + RPI * (0.5_JPRB - REAL (JLAT, JPRB) / REAL (NDGLG+1, JPRB))
(  705)           ZLON = 2 * RPI * REAL (JLON-1, JPRB) / REAL (NLOEN (JLAT))
(  706)           ZVAL = COS (ZLAT) * SIN (ZLON)
(  707)         ENDIF
(  708)         ZGPBUFG (JGLO, 1) = ZVAL
(  709)         JGLO = JGLO + 1
(  710)       ENDDO
(  711)     ENDDO
(  712)   ENDBLOCK
(  713)   ENDIF
(  714) 
(  715)   IF (LELAM) THEN
(  716)     CALL EDIST_GRID (PGPG=ZGPBUFG, KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
(  717)   ELSE
(  718)     CALL DIST_GRID (PGPG=ZGPBUFG, KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
(  719)   ENDIF
(  720) 
(  721)   DEALLOCATE (ZGPBUFG)
(  722) 
(  723) ELSE
(  724)   IF (LELAM) THEN
(  725)     CALL EDIST_GRID (KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
(  726)   ELSE
(  727)     CALL DIST_GRID (KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
(  728)   ENDIF
(  729) ENDIF
(  730) 
(  731) DO IFLD = 2, IFLDGPG
(  732)   ZGPBUFL (:, IFLD, 1) = ZGPBUFL (:, 1, 1) * REAL (IFLD, JPRB)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 14

(  733) ENDDO
(  734) 
(  735) 
(  736) END SUBROUTINE
(  737) 
(  738) END PROGRAM TEST
(  739) 

























































NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 15

(    1) # 1 "aatestprog.F90"
(    1) PROGRAM TEST
(    2) # 3 "aatestprog.F90"
(    3) USE MPL_END_MOD, ONLY : MPL_END
(    4) USE MPL_INIT_MOD, ONLY : MPL_INIT
(    5) USE PARKIND1, ONLY : JPIM, JPRB
(    6) USE MPL_MODULE, ONLY : MPL_BARRIER, MPL_MYRANK, MPL_NPROC
(    7) USE MPL_DATA_MODULE, ONLY : MPL_COMM_OML
(    8) USE YOMHOOK, ONLY : DR_HOOK, LHOOK
(    9) USE SET2PE_MOD, ONLY : SET2PE
(   10) # 11 "aatestprog.F90"
(   11) USE XRD_GETOPTIONS
(   12) # 13 "aatestprog.F90"
(   13) IMPLICIT NONE
(   14) # 15 "aatestprog.F90"
(   15) REAL (KIND=JPRB), PARAMETER :: RPI = 2._JPRB * ASIN (1.0_JPRB)
(   16) REAL (KIND=JPRB), PARAMETER :: DEG2RAD = RPI / 180._JPRB
(   17) # 18 "aatestprog.F90"
(   18) INTEGER(KIND=JPIM) :: NMSMAX, NSMAX, NDGLG, NPRGPNS, NPRGPEW, NPRTRW, NPRTRV, NDLON, NPRINTLEV, NTIME
(   19) INTEGER(KIND=JPIM) :: MYPROC, NPROC, NBSETSP
(   20) INTEGER(KIND=JPIM) :: NFLEV
(   21) INTEGER(KIND=JPIM) :: NFLEVG
(   22) INTEGER(KIND=JPIM) :: NSPEC2, NSPEC2G, NGPTOT, NGPTOTG, MYSETV, MYSETW
(   23) INTEGER(KIND=JPIM), ALLOCATABLE :: NLOEN (:) 
(   24) INTEGER(KIND=JPIM), ALLOCATABLE :: IFLDSCH (:) 
(   25) INTEGER(KIND=JPIM), ALLOCATABLE :: IVSETOFF (:)
(   26) INTEGER(KIND=JPIM), POINTER     :: INFD (:), IFLDOFF (:)
(   27) INTEGER(KIND=JPIM), ALLOCATABLE, TARGET :: INFD_ALLVSETS (:,:), IFLDOFF_ALLVSETS (:,:)
(   28) # 29 "aatestprog.F90"
(   29) REAL (KIND=JPRB) :: ZTSTEP, TIMEF
(   30) # 31 "aatestprog.F90"
(   31) REAL (KIND=JPRB),    ALLOCATABLE :: ZSPBUFL (:,:) 
(   32) REAL (KIND=JPRB),    ALLOCATABLE :: ZSPBUFG (:,:) 
(   33) REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFL (:,:,:) 
(   34) REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFG (:,:) 
(   35) INTEGER (KIND=JPIM), ALLOCATABLE :: NBSETLEV (:) 
(   36) INTEGER (KIND=JPIM), ALLOCATABLE :: IVSET (:) 
(   37) INTEGER (KIND=JPIM) :: NFLDUA, NFLDSU, IFLD, ILEVG, IGPG, JFLDG1, JFLDG2, IPROC
(   38) INTEGER (KIND=JPIM) :: JSETW, JSETV
(   39) INTEGER (KIND=JPIM) :: IFLDGPG, IFLDSPL
(   40) INTEGER (KIND=JPIM) :: IA, IB
(   41) INTEGER (KIND=JPIM) :: NRGRI (8000)
(   42) INTEGER (KIND=JPIM) :: ITIME
(   43) # 44 "aatestprog.F90"
(   44) LOGICAL :: LUSEFLT, LUSERPNM, LKEEPRPNM
(   45) LOGICAL :: LSPLIT, LEQ_REGIONS, LDEBUG, LELAM, LLCHECK
(   46) LOGICAL :: LLHOOK
(   47) # 48 "aatestprog.F90"
(   48) # 1 ".D[13]/setup_trans0.h"
(    1) INTERFACE
(    2) SUBROUTINE SETUP_TRANS0(KOUT,KERR,KPRINTLEV,KMAX_RESOL,KPROMATR,&
(    3) &                       KPRGPNS,KPRGPEW,KPRTRW,KCOMBFLEN,&
(    4) &                       LDMPOFF,LDSYNC_TRANS,KTRANS_SYNC_LEVEL,&
(    5) &                       LDEQ_REGIONS,K_REGIONS_NS,K_REGIONS_EW,K_REGIONS,&
(    6) &                       PRAD,LDALLOPERM)
(    7) # 8 ".D[13]/setup_trans0.h"
(    8) !**** *SETUP_TRANS0* - General setup routine for transform package
(    9) # 10 ".D[13]/setup_trans0.h"






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 16

(   10) !     Purpose.
(   11) !     --------
(   12) !     Resolution independent part of setup of transform package
(   13) !     Has to be called BEFORE SETUP_TRANS
(   14) # 15 ".D[13]/setup_trans0.h"
(   15) !**   Interface.
(   16) !     ----------
(   17) !     CALL SETUP_TRANS0(...)
(   18) # 19 ".D[13]/setup_trans0.h"
(   19) !     Explicit arguments : All arguments are optional, [..] default value
(   20) !     -------------------
(   21) !     KOUT - Unit number for listing output [6]
(   22) !     KERR - Unit number for error messages [0]
(   23) !     KPRINTLEV - level of output to KOUT, 0->no output,1->normal,2->debug [0]
(   24) !     KMAX_RESOL - maximum number of different resolutions for this run [1]
(   25) !     KPRGPNS - splitting level in N-S direction in grid-point space [1]
(   26) !     KPRGPEW - splitting level in E-W direction in grid-point space [1]
(   27) !     KPRTRW  - splitting level in wave direction in spectral space [1]
(   28) !     KCOMBFLEN - Size of communication buffer [1800000 (*8bytes) ]
(   29) !     LDMPOFF - switch off message passing [false]
(   30) !     LDSYNC_TRANS - switch to activate barrier before transforms [false]
(   31) !     KTRANS_SYNC_LEVEL - use of synchronization/blocking [0]
(   32) !     LDEQ_REGIONS - true if new eq_regions partitioning [false]
(   33) !     K_REGIONS    - Number of regions (1D or 2D partitioning)
(   34) !     K_REGIONS_NS - Maximum number of NS partitions
(   35) !     K_REGIONS_EW - Maximum number of EW partitions
(   36) !     PRAD         - Radius of the planet
(   37) !     LDALLOPERM  - Allocate certain arrays permanently
(   38) # 39 ".D[13]/setup_trans0.h"
(   39) !     The total number of (MPI)-processors has to be equal to KPRGPNS*KPRGPEW
(   40) # 41 ".D[13]/setup_trans0.h"
(   41) !     Method.
(   42) !     -------
(   43) # 44 ".D[13]/setup_trans0.h"
(   44) !     Externals.  SUMP_TRANS0 - initial setup routine
(   45) !     ----------
(   46) # 47 ".D[13]/setup_trans0.h"
(   47) !     Author.
(   48) !     -------
(   49) !        Mats Hamrud *ECMWF*
(   50) # 51 ".D[13]/setup_trans0.h"
(   51) !     Modifications.
(   52) !     --------------
(   53) !        Original : 00-03-03
(   54) !        R. El Khatib 03-01-24 LDMPOFF
(   55) !        G. Mozdzynski 2006-09-13 LDEQ_REGIONS
(   56) !        N. Wedi  2009-11-30 add radius
(   57) # 58 ".D[13]/setup_trans0.h"
(   58) !     ------------------------------------------------------------------
(   59) # 60 ".D[13]/setup_trans0.h"
(   60) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   61) # 62 ".D[13]/setup_trans0.h"
(   62) IMPLICIT NONE
(   63) # 64 ".D[13]/setup_trans0.h"
(   64) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN)  :: KOUT,KERR,KPRINTLEV,KMAX_RESOL,KPROMATR
(   65) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN)  :: KPRGPNS,KPRGPEW,KPRTRW,KCOMBFLEN
(   66) LOGICAL            ,OPTIONAL,INTENT(IN)  :: LDMPOFF
(   67) LOGICAL            ,OPTIONAL,INTENT(IN)  :: LDSYNC_TRANS






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 17

(   68) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN)  :: KTRANS_SYNC_LEVEL
(   69) LOGICAL            ,OPTIONAL,INTENT(IN)  :: LDEQ_REGIONS
(   70) LOGICAL            ,OPTIONAL,INTENT(IN)  :: LDALLOPERM
(   71) REAL(KIND=JPRB)    ,OPTIONAL,INTENT(IN)  :: PRAD
(   72) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(OUT) :: K_REGIONS(:)
(   73) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(OUT) :: K_REGIONS_NS
(   74) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(OUT) :: K_REGIONS_EW
(   75) # 76 ".D[13]/setup_trans0.h"
(   76) END SUBROUTINE SETUP_TRANS0
(   77) # 80 ".D[13]/setup_trans0.h"
(   80) END INTERFACE
(   81) # 49 "aatestprog.F90"
(   49) # 50 "aatestprog.F90"
(   50) # 1 ".D[13]/setup_trans.h"
(    1) INTERFACE
(    2) SUBROUTINE SETUP_TRANS(KSMAX,KDGL,KDLON,KLOEN,LDSPLIT,PSTRET,&
(    3) &KFLEV,KTMAX,KRESOL,PWEIGHT,LDGRIDONLY,LDUSERPNM,LDKEEPRPNM,LDUSEFLT,&
(    4) &LDSPSETUPONLY,LDPNMONLY,LDUSEFFTW,&
(    5) &LDLL,LDSHIFTLL,CDIO_LEGPOL,CDLEGPOLFNAME,KLEGPOLPTR,KLEGPOLPTR_LEN)
(    6) # 7 ".D[13]/setup_trans.h"
(    7) !**** *SETUP_TRANS* - Setup transform package for specific resolution
(    8) # 9 ".D[13]/setup_trans.h"
(    9) !     Purpose.
(   10) !     --------
(   11) !     To setup for making spectral transforms. Each call to this routine
(   12) !     creates a new resolution up to a maximum of NMAX_RESOL set up in
(   13) !     SETUP_TRANS0. You need to call SETUP_TRANS0 before this routine can
(   14) !     be called.
(   15) # 16 ".D[13]/setup_trans.h"
(   16) !**   Interface.
(   17) !     ----------
(   18) !     CALL SETUP_TRANS(...)
(   19) # 20 ".D[13]/setup_trans.h"
(   20) !     Explicit arguments : KLOEN,LDSPLIT are optional arguments
(   21) !     -------------------- 
(   22) !     KSMAX - spectral truncation required
(   23) !     KDGL  - number of Gaussian latitudes
(   24) !     KDLON - number of points on each latitude [2*KDGL]
(   25) !     KLOEN(:) - number of points on each Gaussian latitude [2*KDGL]
(   26) !     LDSPLIT - true if split latitudes in grid-point space [false]
(   27) !     KTMAX - truncation order for tendencies?
(   28) !     KRESOL - the resolution identifier
(   29) !     PWEIGHT - the weight per grid-point (for a weighted distribution)
(   30) !     LDGRIDONLY - true if only grid space is required
(   31) # 32 ".D[13]/setup_trans.h"
(   32) !     KSMAX,KDGL,KTMAX and KLOEN are GLOBAL variables desribing the resolution
(   33) !     in spectral and grid-point space
(   34) # 35 ".D[13]/setup_trans.h"
(   35) !     LDSPLIT describe the distribution among processors of grid-point data and
(   36) !     has no relevance if you are using a single processor
(   37) # 38 ".D[13]/setup_trans.h"
(   38) !     LDUSEFLT   - use Fast Legandre Transform (Butterfly algorithm)
(   39) !     LDUSERPNM  - Use Belusov to compute legendre pol. (else new alg.)
(   40) !     LDKEEPRPNM - Keep Legendre Polynomials (only applicable when using
(   41) !                  FLT, otherwise always kept)
(   42) !     LDPNMONLY  - Compute the Legendre polynomialsonly, not the FFTs.
(   43) !     LDUSEFFTW   - Use FFTW for FFTs
(   44) !     LDLL                 - Setup second set of input/output latitudes






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 18

(   45) !                                 the number of input/output latitudes to transform is equal KDGL 
(   46) !                                 or KDGL+2 in the case that includes poles + equator
(   47) !                                 the number of input/output longitudes to transform is 2*KDGL
(   48) !     LDSHIFTLL       - Shift output lon/lat data by 0.5*dx and 0.5*dy
(   49)  
(   50) !     Method.
(   51) !     -------
(   52) # 53 ".D[13]/setup_trans.h"
(   53) !     Externals.  SET_RESOL   - set resolution
(   54) !     ----------  SETUP_DIMS  - setup distribution independent dimensions
(   55) !                 SUMP_TRANS_PRELEG - first part of setup of distr. environment
(   56) !                 SULEG - Compute Legandre polonomial and Gaussian 
(   57) !                         Latitudes and Weights
(   58) !                 SUMP_TRANS - Second part of setup of distributed environment
(   59) !                 SUFFT - setup for FFT
(   60) # 61 ".D[13]/setup_trans.h"
(   61) !     Author.
(   62) !     -------
(   63) !        Mats Hamrud *ECMWF*
(   64) # 65 ".D[13]/setup_trans.h"
(   65) !     Modifications.
(   66) !     --------------
(   67) !        Original : 00-03-03
(   68) # 69 ".D[13]/setup_trans.h"
(   69) !     ------------------------------------------------------------------
(   70) # 71 ".D[13]/setup_trans.h"
(   71) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   72)     USE, INTRINSIC :: ISO_C_BINDING, ONLY:  C_PTR, C_INT,C_ASSOCIATED,C_SIZE_T
(   73) # 75 ".D[13]/setup_trans.h"
(   75) IMPLICIT NONE
(   76) # 77 ".D[13]/setup_trans.h"
(   77) ! Dummy arguments
(   78) # 79 ".D[13]/setup_trans.h"
(   79) INTEGER(KIND=JPIM) ,INTENT(IN) :: KSMAX,KDGL
(   80) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN) :: KDLON
(   81) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN) :: KLOEN(:)
(   82) LOGICAL   ,OPTIONAL,INTENT(IN) :: LDSPLIT
(   83) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN) :: KTMAX
(   84) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(OUT):: KRESOL
(   85) REAL(KIND=JPRB)    ,OPTIONAL,INTENT(IN) :: PWEIGHT(:)
(   86) REAL(KIND=JPRB)    ,OPTIONAL,INTENT(IN) :: PSTRET
(   87) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN) :: KFLEV
(   88) LOGICAL   ,OPTIONAL,INTENT(IN):: LDGRIDONLY
(   89) LOGICAL   ,OPTIONAL,INTENT(IN):: LDUSEFLT
(   90) LOGICAL   ,OPTIONAL,INTENT(IN):: LDUSERPNM
(   91) LOGICAL   ,OPTIONAL,INTENT(IN):: LDKEEPRPNM
(   92) LOGICAL   ,OPTIONAL,INTENT(IN):: LDPNMONLY
(   93) LOGICAL   ,OPTIONAL,INTENT(IN):: LDSPSETUPONLY
(   94) LOGICAL   ,OPTIONAL,INTENT(IN):: LDUSEFFTW
(   95) LOGICAL   ,OPTIONAL,INTENT(IN):: LDLL
(   96) LOGICAL   ,OPTIONAL,INTENT(IN):: LDSHIFTLL
(   97) CHARACTER(LEN=*),OPTIONAL,INTENT(IN):: CDIO_LEGPOL
(   98) CHARACTER(LEN=*),OPTIONAL,INTENT(IN):: CDLEGPOLFNAME
(   99) TYPE(C_PTR) ,OPTIONAL,INTENT(IN) :: KLEGPOLPTR
(  100) INTEGER(C_SIZE_T) ,OPTIONAL,INTENT(IN) :: KLEGPOLPTR_LEN
(  101) # 103 ".D[13]/setup_trans.h"
(  103) END SUBROUTINE SETUP_TRANS
(  104) # 106 ".D[13]/setup_trans.h"






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 19

(  106) END INTERFACE
(  107) # 51 "aatestprog.F90"
(   51) # 51 "aatestprog.F90"
(   51) # 1 ".D[13]/trans_inq.h"
(    1) INTERFACE
(    2) SUBROUTINE TRANS_INQ(KRESOL,KSPEC,KSPEC2,KSPEC2G,KSPEC2MX,KNUMP,&
(    3)                     &KGPTOT,KGPTOTG,KGPTOTMX,KGPTOTL,&
(    4)                     &KMYMS,KASM0,KUMPP,KPOSSP,KPTRMS,KALLMS,KDIM0G,&
(    5)                     &KFRSTLAT,KLSTLAT,KFRSTLOFF,KPTRLAT,&
(    6)                     &KPTRFRSTLAT,KPTRLSTLAT,KPTRFLOFF,KSTA,KONL,&
(    7)                     &KULTPP,KPTRLS,KNMENG,&
(    8)                     &KPRTRW,KMYSETW,KMYSETV,KMY_REGION_NS,KMY_REGION_EW,&
(    9)                     &LDSPLITLAT,&
(   10)                     &KSMAX,PLAPIN,KNVALUE,KDEF_RESOL,LDLAM,&
(   11)                     &PMU,PGW,PRPNM,KLEI3,KSPOLEGL,KPMS,KDGLU)
(   12) # 13 ".D[13]/trans_inq.h"
(   13) !**** *TRANS_INQ* - Extract information from the transform package
(   14) # 15 ".D[13]/trans_inq.h"
(   15) !     Purpose.
(   16) !     --------
(   17) !     Interface routine for extracting information from the T.P.
(   18) # 19 ".D[13]/trans_inq.h"
(   19) !**   Interface.
(   20) !     ----------
(   21) !     CALL TRANS_INQ(...)
(   22) !     Explicit arguments : All arguments are optional.
(   23) !     -------------------- 
(   24) !     KRESOL   - resolution tag for which info is required ,default is the
(   25) !                first defined resulution (input)
(   26) # 27 ".D[13]/trans_inq.h"
(   27) !                   MULTI-TRANSFORMS MANAGEMENT
(   28) !     KDEF_RESOL - number or resolutions defined
(   29) !     LDLAM      - .T. if the corresponding resolution is LAM, .F. if it is global
(   30) # 31 ".D[13]/trans_inq.h"
(   31) !                   SPECTRAL SPACE
(   32) !     KSPEC    - number of complex spectral coefficients on this PE
(   33) !     KSPEC2   - 2*KSPEC 
(   34) !     KSPEC2G  - global KSPEC2
(   35) !     KSPEC2MX - maximun KSPEC2 among all PEs
(   36) !     KNUMP    - Number of spectral waves handled by this PE
(   37) !     KGPTOT   - Total number of grid columns on this PE
(   38) !     KGPTOTG  - Total number of grid columns on the Globe
(   39) !     KGPTOTMX - Maximum number of grid columns on any of the PEs
(   40) !     KGPTOTL  - Number of grid columns one each PE (dimension N_REGIONS_NS:N_REGIONS_EW)
(   41) !     KMYMS    - This PEs spectral zonal wavenumbers
(   42) !     KASM0    - Address in a spectral array of (m, n=m)
(   43) !     KUMPP    - No. of wave numbers each wave set is responsible for
(   44) !     KPOSSP   - Defines partitioning of global spectral fields among PEs
(   45) !     KPTRMS   - Pointer to the first wave number of a given a-set
(   46) !     KALLMS   - Wave numbers for all wave-set concatenated together 
(   47) !                to give all wave numbers in wave-set order
(   48) !     KDIM0G   - Defines partitioning of global spectral fields among PEs
(   49) !     KSMAX    - spectral truncation
(   50) !     KNVALUE  - n value for each KSPEC2 spectral coeffient
(   51) # 52 ".D[13]/trans_inq.h"
(   52) !                 GRIDPOINT SPACE                  
(   53) !     KFRSTLAT    - First latitude of each a-set in grid-point space
(   54) !     KLSTTLAT    - Last latitude of each a-set in grid-point space






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 20

(   55) !     KFRSTLOFF   - Offset for first lat of own a-set in grid-point space
(   56) !     KPTRLAT     - Pointer to the start of each latitude
(   57) !     KPTRFRSTLAT - Pointer to the first latitude of each a-set in 
(   58) !                   NSTA and NONL arrays
(   59) !     KPTRLSTLAT  - Pointer to the last latitude of each a-set in
(   60) !                   NSTA and NONL arrays
(   61) !     KPTRFLOFF   - Offset for pointer to the first latitude of own a-set
(   62) !                   NSTA and NONL arrays, i.e. nptrfrstlat(myseta)-1
(   63) !     KSTA        - Position of first grid column for the latitudes on a 
(   64) !                   processor. The information is available for all processors.
(   65) !                   The b-sets are distinguished by the last dimension of 
(   66) !                   nsta().The latitude band for each a-set is addressed by 
(   67) !                   nptrfrstlat(jaset),nptrlstlat(jaset), and 
(   68) !                   nptrfloff=nptrfrstlat(myseta) on this processors a-set.
(   69) !                   Each split latitude has two entries in nsta(,:) which 
(   70) !                   necessitates the rather complex addressing of nsta(,:)
(   71) !                   and the overdimensioning of nsta by N_REGIONS_NS.
(   72) !     KONL        - Number of grid columns for the latitudes on a processor.
(   73) !                   Similar to nsta() in data structure.
(   74) !     LDSPLITLAT  - TRUE if latitude is split in grid point space over 
(   75) !                   two a-sets
(   76) # 77 ".D[13]/trans_inq.h"
(   77) !                FOURIER SPACE
(   78) !     KULTPP   - number of latitudes for which each a-set is calculating 
(   79) !                the FFT's.
(   80) !     KPTRLS   - pointer to first global latitude of each a-set for which
(   81) !                it performs the Fourier calculations
(   82) !     KNMENG   - associated (with NLOENG) cut-off zonal wavenumber
(   83) # 84 ".D[13]/trans_inq.h"
(   84) !                 LEGENDRE
(   85) !     PMU      - sin(Gaussian latitudes)
(   86) !     PGW      - Gaussian weights
(   87) !     PRPNM    - Legendre polynomials
(   88) !     KLEI3    - First dimension of Legendre polynomials
(   89) !     KSPOLEGL - Second dimension of Legendre polynomials
(   90) !     KPMS     - Adress for legendre polynomial for given M (NSMAX)
(   91) !     PLAPIN   - Eigen-values of the inverse Laplace operator
(   92) !     KDGLU    - Number of active points in an hemisphere for a given wavenumber "m"
(   93) # 94 ".D[13]/trans_inq.h"
(   94) !     Method.
(   95) !     -------
(   96) # 97 ".D[13]/trans_inq.h"
(   97) !     Externals.  SET_RESOL - set resolution
(   98) !     ----------  
(   99) # 100 ".D[13]/trans_inq.h"
(  100) !     Author.
(  101) !     -------
(  102) !        Mats Hamrud *ECMWF*
(  103) # 104 ".D[13]/trans_inq.h"
(  104) !     Modifications.
(  105) !     --------------
(  106) !        Original : 00-03-03
(  107) !        M. Hortal : 2001-03-05 Dimensions of the Legendre polynomials
(  108) !        R. El Khatib 08-Aug-2012 KSMAX,PLAPIN,KNVALUE,LDLAM,KDEF_RESOL
(  109) # 110 ".D[13]/trans_inq.h"
(  110) !     ------------------------------------------------------------------
(  111) # 112 ".D[13]/trans_inq.h"
(  112) USE PARKIND1  ,ONLY : JPIM     ,JPRB, JPRD






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 21

(  113) # 115 ".D[13]/trans_inq.h"
(  115) IMPLICIT NONE
(  116) # 117 ".D[13]/trans_inq.h"
(  117) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KRESOL
(  118) # 119 ".D[13]/trans_inq.h"
(  119) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC
(  120) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2
(  121) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2G
(  122) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2MX
(  123) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNUMP
(  124) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOT
(  125) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTG
(  126) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTMX
(  127) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTL(:,:)
(  128) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KFRSTLOFF
(  129) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRFLOFF
(  130) # 131 ".D[13]/trans_inq.h"
(  131) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYMS(:)
(  132) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KASM0(0:)
(  133) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KUMPP(:)
(  134) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPOSSP(:)
(  135) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRMS(:)
(  136) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KALLMS(:)
(  137) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDIM0G(0:)
(  138) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KFRSTLAT(:)
(  139) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KLSTLAT(:)
(  140) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLAT(:)
(  141) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRFRSTLAT(:)
(  142) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLSTLAT(:)
(  143) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSTA(:,:)
(  144) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KONL(:,:)
(  145) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPRTRW
(  146) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETW
(  147) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETV
(  148) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_NS
(  149) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_EW
(  150) LOGICAL   ,OPTIONAL, INTENT(OUT) :: LDSPLITLAT(:)
(  151) # 152 ".D[13]/trans_inq.h"
(  152) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KULTPP(:)
(  153) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLS(:)
(  154) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNMENG(:)
(  155) # 156 ".D[13]/trans_inq.h"
(  156) REAL(KIND=JPRD)    ,OPTIONAL, INTENT(OUT) :: PMU(:)
(  157) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PGW(:)
(  158) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PRPNM(:,:)
(  159) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KLEI3
(  160) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPOLEGL
(  161) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPMS(0:)
(  162) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDGLU(0:)
(  163) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PLAPIN(-1:)
(  164) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSMAX
(  165) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNVALUE(:)
(  166) # 167 ".D[13]/trans_inq.h"
(  167) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDEF_RESOL
(  168) LOGICAL           ,OPTIONAL,INTENT(OUT)   :: LDLAM
(  169) # 170 ".D[13]/trans_inq.h"
(  170) END SUBROUTINE TRANS_INQ
(  171) # 177 ".D[13]/trans_inq.h"






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 22

(  177) END INTERFACE
(  178) # 52 "aatestprog.F90"
(   52) # 52 "aatestprog.F90"
(   52) # 1 ".D[13]/dist_grid.h"
(    1) INTERFACE
(    2) SUBROUTINE DIST_GRID(PGPG,KPROMA,KFDISTG,KFROM,KRESOL,PGP,KSORT)
(    3) # 4 ".D[13]/dist_grid.h"
(    4) !**** *DIST_GRID* - Distribute global gridpoint array among processors
(    5) # 6 ".D[13]/dist_grid.h"
(    6) !     Purpose.
(    7) !     --------
(    8) !        Interface routine for distributing gridpoint array
(    9) # 10 ".D[13]/dist_grid.h"
(   10) !**   Interface.
(   11) !     ----------
(   12) !     CALL DIST_GRID(...)
(   13) # 14 ".D[13]/dist_grid.h"
(   14) !     Explicit arguments : 
(   15) !     -------------------- 
(   16) !     PGPG(:,:) - Global spectral array
(   17) !     KFDISTG     - Global number of fields to be distributed
(   18) !     KPROMA      - required blocking factor for gridpoint input
(   19) !     KFROM(:)    - Processor resposible for distributing each field
(   20) !     KRESOL      - resolution tag  which is required ,default is the
(   21) !                   first defined resulution (input)
(   22) !     PGP(:,:)  - Local spectral array
(   23) !
(   24) !     Method.
(   25) !     -------
(   26) # 27 ".D[13]/dist_grid.h"
(   27) !     Externals.  SET_RESOL      - set resolution
(   28) !     ----------  DIST_GRID_CTL  - control routine
(   29) # 30 ".D[13]/dist_grid.h"
(   30) !     Author.
(   31) !     -------
(   32) !        Mats Hamrud *ECMWF*
(   33) # 34 ".D[13]/dist_grid.h"
(   34) !     Modifications.
(   35) !     --------------
(   36) !        Original : 00-03-03
(   37) # 38 ".D[13]/dist_grid.h"
(   38) !     ------------------------------------------------------------------
(   39) # 40 ".D[13]/dist_grid.h"
(   40) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   41) # 43 ".D[13]/dist_grid.h"
(   43) IMPLICIT NONE
(   44) # 45 ".D[13]/dist_grid.h"
(   45) ! Declaration of arguments
(   46) # 47 ".D[13]/dist_grid.h"
(   47) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN)  :: PGPG(:,:)
(   48) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KPROMA
(   49) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KFDISTG
(   50) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KFROM(:)
(   51) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KRESOL
(   52) REAL(KIND=JPRB)             , INTENT(OUT) :: PGP(:,:,:)
(   53) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KSORT (:)
(   54) # 56 ".D[13]/dist_grid.h"
(   56) !     ------------------------------------------------------------------






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 23

(   57) # 58 ".D[13]/dist_grid.h"
(   58) END SUBROUTINE DIST_GRID
(   59) # 60 ".D[13]/dist_grid.h"
(   60) END INTERFACE
(   61) # 53 "aatestprog.F90"
(   53) # 53 "aatestprog.F90"
(   53) # 1 ".D[13]/gath_grid.h"
(    1) INTERFACE
(    2) SUBROUTINE GATH_GRID(PGPG,KPROMA,KFGATHG,KTO,KRESOL,PGP)
(    3) # 4 ".D[13]/gath_grid.h"
(    4) !**** *GATH_GRID* - Gather global gridpoint array from processors
(    5) # 6 ".D[13]/gath_grid.h"
(    6) !     Purpose.
(    7) !     --------
(    8) !        Interface routine for gathering gripoint array
(    9) # 10 ".D[13]/gath_grid.h"
(   10) !**   Interface.
(   11) !     ----------
(   12) !     CALL GATH_GRID(...)
(   13) # 14 ".D[13]/gath_grid.h"
(   14) !     Explicit arguments : 
(   15) !     -------------------- 
(   16) !     PGPG(:,:)   - Global gridpoint array
(   17) !     KFGATHG     - Global number of fields to be gathered
(   18) !     KPROMA      - blocking factor for gridpoint input
(   19) !     KTO(:)      - Processor responsible for gathering each field
(   20) !     KRESOL      - resolution tag  which is required ,default is the
(   21) !                   first defined resulution (input)
(   22) !     PGP(:,:,:)  - Local spectral array
(   23) !
(   24) !     Method.
(   25) !     -------
(   26) # 27 ".D[13]/gath_grid.h"
(   27) !     Externals.  SET_RESOL   - set resolution
(   28) !     ----------  GATH_GRID_CTL -  control routine
(   29) # 30 ".D[13]/gath_grid.h"
(   30) !     Author.
(   31) !     -------
(   32) !        Mats Hamrud *ECMWF*
(   33) # 34 ".D[13]/gath_grid.h"
(   34) !     Modifications.
(   35) !     --------------
(   36) !        Original : 00-03-03
(   37) # 38 ".D[13]/gath_grid.h"
(   38) !     ------------------------------------------------------------------
(   39) # 40 ".D[13]/gath_grid.h"
(   40) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   41) # 43 ".D[13]/gath_grid.h"
(   43) IMPLICIT NONE
(   44) # 45 ".D[13]/gath_grid.h"
(   45) ! Declaration of arguments
(   46) # 47 ".D[13]/gath_grid.h"
(   47) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PGPG(:,:)
(   48) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KPROMA
(   49) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KFGATHG
(   50) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KTO(:)
(   51) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KRESOL
(   52) REAL(KIND=JPRB)             , INTENT(IN)  :: PGP(:,:,:)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 24

(   53) # 55 ".D[13]/gath_grid.h"
(   55) !     ------------------------------------------------------------------
(   56) # 57 ".D[13]/gath_grid.h"
(   57) END SUBROUTINE GATH_GRID
(   58) # 59 ".D[13]/gath_grid.h"
(   59) END INTERFACE
(   60) # 54 "aatestprog.F90"
(   54) # 54 "aatestprog.F90"
(   54) # 1 ".D[13]/gath_spec.h"
(    1) INTERFACE
(    2) SUBROUTINE GATH_SPEC(PSPECG,KFGATHG,KTO,KVSET,KRESOL,PSPEC,LDIM1_IS_FLD,KSMAX,LDZA0IP)
(    3) # 4 ".D[13]/gath_spec.h"
(    4) !**** *GATH_SPEC* - Gather global spectral array from processors
(    5) # 6 ".D[13]/gath_spec.h"
(    6) !     Purpose.
(    7) !     --------
(    8) !        Interface routine for gathering spectral array
(    9) # 10 ".D[13]/gath_spec.h"
(   10) !**   Interface.
(   11) !     ----------
(   12) !     CALL GATH_SPEC(...)
(   13) # 14 ".D[13]/gath_spec.h"
(   14) !     Explicit arguments : 
(   15) !     -------------------- 
(   16) !     PSPECG(:,:) - Global spectral array
(   17) !     KFGATHG     - Global number of fields to be gathered
(   18) !     KTO(:)      - Processor responsible for gathering each field
(   19) !     KVSET(:)    - "B-Set" for each field
(   20) !     KRESOL      - resolution tag  which is required ,default is the
(   21) !                   first defined resulution (input)
(   22) !     PSPEC(:,:)  - Local spectral array
(   23) !     LDIM1_IS_FLD - If TRUE first dimension of PSCPEC and PSPECG is the field dimension [.T.]
(   24) !
(   25) !     Method.
(   26) !     -------
(   27) # 28 ".D[13]/gath_spec.h"
(   28) !     Externals.  SET_RESOL   - set resolution
(   29) !     ----------  GATH_SPEC_CONTROL - control routine
(   30) # 31 ".D[13]/gath_spec.h"
(   31) !     Author.
(   32) !     -------
(   33) !        Mats Hamrud *ECMWF*
(   34) # 35 ".D[13]/gath_spec.h"
(   35) !     Modifications.
(   36) !     --------------
(   37) !        Original : 00-03-03
(   38) # 39 ".D[13]/gath_spec.h"
(   39) !     ------------------------------------------------------------------
(   40) # 41 ".D[13]/gath_spec.h"
(   41) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   42) # 44 ".D[13]/gath_spec.h"
(   44) IMPLICIT NONE
(   45) # 46 ".D[13]/gath_spec.h"
(   46) ! Declaration of arguments
(   47) # 48 ".D[13]/gath_spec.h"
(   48) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPECG(:,:)
(   49) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KFGATHG
(   50) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KTO(:)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 25

(   51) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KVSET(:)
(   52) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KRESOL
(   53) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN)  :: PSPEC(:,:)
(   54) LOGICAL            ,OPTIONAL, INTENT(IN)  :: LDIM1_IS_FLD
(   55) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KSMAX
(   56) LOGICAL            ,OPTIONAL, INTENT(IN)  :: LDZA0IP
(   57) # 59 ".D[13]/gath_spec.h"
(   59) !     ------------------------------------------------------------------
(   60) # 61 ".D[13]/gath_spec.h"
(   61) END SUBROUTINE GATH_SPEC
(   62) # 63 ".D[13]/gath_spec.h"
(   63) END INTERFACE
(   64) # 55 "aatestprog.F90"
(   55) # 55 "aatestprog.F90"
(   55) # 1 ".D[13]/dir_trans.h"
(    1) INTERFACE
(    2) SUBROUTINE DIR_TRANS(PSPVOR,PSPDIV,PSPSCALAR,PSPSC3A,PSPSC3B,PSPSC2,&
(    3) & LDLATLON,KPROMA,KVSETUV,KVSETSC,KRESOL,KVSETSC3A,KVSETSC3B,KVSETSC2,&
(    4) & PGP,PGPUV,PGP3A,PGP3B,PGP2)
(    5) # 7 ".D[13]/dir_trans.h"
(    7) !**** *DIR_TRANS* - Direct spectral transform (from grid-point to spectral).
(    8) # 9 ".D[13]/dir_trans.h"
(    9) !     Purpose.
(   10) !     --------
(   11) !        Interface routine for the direct spectral transform
(   12) # 13 ".D[13]/dir_trans.h"
(   13) !**   Interface.
(   14) !     ----------
(   15) !     CALL DIR_TRANS(...)
(   16) # 17 ".D[13]/dir_trans.h"
(   17) !     Explicit arguments : All arguments except from PGP are optional.
(   18) !     -------------------- 
(   19) !     PSPVOR(:,:) - spectral vorticity (output)
(   20) !     PSPDIV(:,:) - spectral divergence (output)
(   21) !     PSPSCALAR(:,:) - spectral scalarvalued fields (output)
(   22) !     PSPSC3A(:,:,:) - alternative to use of PSPSCALAR, see PGP3A below (input)
(   23) !     PSPSC3B(:,:,:) - alternative to use of PSPSCALAR, see PGP3B below (input)
(   24) !     PSPSC2(:,:)  - alternative to use of PSPSCALAR, see PGP2 below (input)
(   25) !     LDLATLON   - indicating if regular lat-lon is the input data
(   26) !     KPROMA      - required blocking factor for gridpoint output
(   27) !     KVSETUV(:)  - indicating which 'b-set' in spectral space owns a 
(   28) !                   vor/div field. Equivalant to NBSETLEV in the IFS.
(   29) !                   The length of KVSETUV should be the GLOBAL number
(   30) !                   of u/v fields which is the dimension of u and v releated
(   31) !                   fields in grid-point space. 
(   32) !     KVESETSC(:) - indicating which 'b-set' in spectral space owns a
(   33) !                   scalar field. As for KVSETUV this argument is required
(   34) !                   if the total number of processors is greater than
(   35) !                   the number of processors used for distribution in
(   36) !                   spectral wave space.  
(   37) !     KVSETSC3A(:) - as KVESETSC for PSPSC3A (distribution on first dimension)
(   38) !     KVSETSC3B(:) - as KVESETSC for PSPSC3B (distribution on first dimension)
(   39) !     KVSETSC2(:) - as KVESETSC for PSPSC2 (distribution on first dimension)
(   40) !     KRESOL   - resolution tag  which is required ,default is the
(   41) !                first defined resulution (input)
(   42) !     PGP(:,:,:) - gridpoint fields (input)
(   43) !                  PGP need to  dimensioned (NPROMA,IF_GP,NGPBLKS) where
(   44) !                  NPROMA is the blocking factor, IF_GP the total number






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 26

(   45) !                  of output fields and NGPBLKS the number of NPROMA blocks.
(   46) !                  The ordering of the output fields is as follows (all 
(   47) !                  parts are optional depending on the input switches):
(   48) !
(   49) !     u             : IF_UV_G fields (if psvor present)
(   50) !     v             : IF_UV_G fields (if psvor present)
(   51) !     scalar fields : IF_SCALARS_G fields (if pspscalar present)
(   52) !   
(   53) !     Here IF_UV_G is the GLOBAL number of u/v fields as given by the length
(   54) !     of KVSETUV (or by PSPVOR if no split in spectral 'b-set' direction
(   55) !     IF_SCALARS_G is the GLOBAL number of scalar fields as giben by the 
(   56) !     length of KVESETSC (or by number of fields in PSPSCALAR if no spectral
(   57) !     'b-set' split
(   58) # 59 ".D[13]/dir_trans.h"
(   59) !     As an alternative to using PGP you can also use a combination of the
(   60) !     following arrays. The reason for introducing these alternative ways
(   61) !     of calling DIR_TRANS is to avoid uneccessary copies where your data
(   62) !     structures don't fit in to the 'PSPVOR,PSPDIV, PSPSCALAR, PGP' layout.
(   63) !     The use of any of these precludes the use of PGP and vice versa.
(   64) # 65 ".D[13]/dir_trans.h"
(   65) !     PGPUV(:,:,:,:) - the 'u-v' related grid-point variables in the order
(   66) !                      described for PGP. The second dimension of PGPUV should
(   67) !                      be the same as the "global" first dimension of 
(   68) !                      PSPVOR,PSPDIV (in the IFS this is the number of levels)
(   69) !                      PGPUV need to be dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   70) !                      IFLDS is the number of 'variables' (u,v)
(   71) !     PGP3A(:,:,:,:) - grid-point array directly connected with PSPSC3A
(   72) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   73) !                      IFLDS is the number of 'variables' (the same as in
(   74) !                      PSPSC3A )
(   75) !     PGP3B(:,:,:,:) - grid-point array directly connected with PSPSC3B
(   76) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   77) !                      IFLDS is the number of 'variables' (the same as in
(   78) !                      PSPSC3B)
(   79) !     PGP2(:,:,:)    - grid-point array directly connected with PSPSC2
(   80) !                      dimensioned(NPROMA,IFLDS,NGPBLKS)
(   81) !                      IFLDS is the number of 'variables' (the same as in
(   82) !                      PSPSC2 )
(   83) ! 
(   84) !     Method.
(   85) !     -------
(   86) # 87 ".D[13]/dir_trans.h"
(   87) !     Externals.  SET_RESOL   - set resolution
(   88) !     ----------  LTDIR_CTL   - control of Legendre transform
(   89) !                 FTDIR_CTL   - control of Fourier transform
(   90) # 91 ".D[13]/dir_trans.h"
(   91) !     Author.
(   92) !     -------
(   93) !        Mats Hamrud *ECMWF*
(   94) # 95 ".D[13]/dir_trans.h"
(   95) !     Modifications.
(   96) !     --------------
(   97) !        Original : 00-03-03
(   98) # 99 ".D[13]/dir_trans.h"
(   99) !     ------------------------------------------------------------------
(  100) # 101 ".D[13]/dir_trans.h"
(  101) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  102) # 104 ".D[13]/dir_trans.h"






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 27

(  104) IMPLICIT NONE
(  105) # 106 ".D[13]/dir_trans.h"
(  106) ! Declaration of arguments
(  107) # 108 ".D[13]/dir_trans.h"
(  108) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPVOR(:,:)
(  109) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPDIV(:,:)
(  110) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSCALAR(:,:)
(  111) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSC3A(:,:,:)
(  112) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSC3B(:,:,:)
(  113) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSC2(:,:)
(  114) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KPROMA
(  115) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETUV(:)
(  116) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC(:)
(  117) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3A(:)
(  118) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3B(:)
(  119) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC2(:)
(  120) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KRESOL
(  121) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDLATLON
(  122) # 123 ".D[13]/dir_trans.h"
(  123) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP(:,:,:)
(  124) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGPUV(:,:,:,:)
(  125) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP3A(:,:,:,:)
(  126) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP3B(:,:,:,:)
(  127) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP2(:,:,:)
(  128) # 130 ".D[13]/dir_trans.h"
(  130) END SUBROUTINE DIR_TRANS
(  131) # 132 ".D[13]/dir_trans.h"
(  132) END INTERFACE
(  133) # 56 "aatestprog.F90"
(   56) # 56 "aatestprog.F90"
(   56) # 1 ".D[13]/inv_trans.h"
(    1) INTERFACE
(    2) SUBROUTINE INV_TRANS(PSPVOR,PSPDIV,PSPSCALAR,PSPSC3A,PSPSC3B,PSPSC2,&
(    3)  & FSPGL_PROC,&
(    4)  & LDSCDERS,LDVORGP,LDDIVGP,LDUVDER,LDLATLON,KPROMA,KVSETUV,KVSETSC,KRESOL,&
(    5)  & KVSETSC3A,KVSETSC3B,KVSETSC2,&
(    6)  & PGP,PGPUV,PGP3A,PGP3B,PGP2)
(    7) # 8 ".D[13]/inv_trans.h"
(    8) !**** *INV_TRANS* - Inverse spectral transform.
(    9) # 10 ".D[13]/inv_trans.h"
(   10) !     Purpose.
(   11) !     --------
(   12) !        Interface routine for the inverse spectral transform
(   13) # 14 ".D[13]/inv_trans.h"
(   14) !**   Interface.
(   15) !     ----------
(   16) !     CALL INV_TRANS(...)
(   17) # 18 ".D[13]/inv_trans.h"
(   18) !     Explicit arguments : All arguments are optional.
(   19) !     -------------------- 
(   20) !     PSPVOR(:,:) - spectral vorticity (input)
(   21) !     PSPDIV(:,:) - spectral divergence (input)
(   22) !     PSPSCALAR(:,:) - spectral scalarvalued fields (input)
(   23) !     PSPSC3A(:,:,:) - alternative to use of PSPSCALAR, see PGP3A below (input)
(   24) !     PSPSC3B(:,:,:) - alternative to use of PSPSCALAR, see PGP3B below (input)
(   25) !     PSPSC2(:,:)  - alternative to use of PSPSCALAR, see PGP2 below (input)
(   26) !     FSPGL_PROC  - external procedure to be executed in fourier space
(   27) !                   before transposition  






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 28

(   28) !     LDSCDERS    - indicating if derivatives of scalar variables are req.
(   29) !     LDVORGP     - indicating if grid-point vorticity is req.
(   30) !     LDDIVGP     - indicating if grid-point divergence is req.
(   31) !     LDUVDER     - indicating if E-W derivatives of u and v are req.
(   32) !     LDLATLON   - indicating if regular lat-lon output requested
(   33) !     KPROMA      - required blocking factor for gridpoint output
(   34) !     KVSETUV(:)  - indicating which 'b-set' in spectral space owns a 
(   35) !                   vor/div field. Equivalant to NBSETLEV in the IFS.
(   36) !                   The length of KVSETUV should be the GLOBAL number
(   37) !                   of u/v fields which is the dimension of u and v releated
(   38) !                   fields in grid-point space. 
(   39) !     KVESETSC(:) - indicating which 'b-set' in spectral space owns a
(   40) !                   scalar field. As for KVSETUV this argument is required
(   41) !                   if the total number of processors is greater than
(   42) !                   the number of processors used for distribution in
(   43) !                   spectral wave space.
(   44) !     KVSETSC3A(:) - as KVESETSC for PSPSC3A (distribution on first dimension)
(   45) !     KVSETSC3B(:) - as KVESETSC for PSPSC3B (distribution on first dimension)
(   46) !     KVSETSC2(:) - as KVESETSC for PSPSC2 (distribution on first dimension)
(   47) !     KRESOL   - resolution tag  which is required ,default is the
(   48) !                first defined resulution (input)
(   49) !     PGP(:,:,:) - gridpoint fields (output)
(   50) !                  PGP need to  dimensioned (NPROMA,IF_GP,NGPBLKS) where
(   51) !                  NPROMA is the blocking factor, IF_GP the total number
(   52) !                  of output fields and NGPBLKS the number of NPROMA blocks.
(   53) !                  The ordering of the output fields is as follows (all 
(   54) !                  parts are optional depending on the input switches):
(   55) !
(   56) !       vorticity     : IF_UV_G fields (if psvor present and LDVORGP)
(   57) !       divergence    : IF_UV_G fields (if psvor present and LDDIVGP)
(   58) !       u             : IF_UV_G fields (if psvor present)
(   59) !       v             : IF_UV_G fields (if psvor present)
(   60) !       scalar fields : IF_SCALARS_G fields (if pspscalar present)
(   61) !       N-S derivative of scalar fields : IF_SCALARS_G fields (if pspscalar
(   62) !                                         present and LDSCDERS)
(   63) !       E-W derivative of u : IF_UV_G fields (if psvor present and and LDUVDER)
(   64) !       E-W derivative of v : IF_UV_G fields (if psvor present and and LDUVDER)
(   65) !       E-W derivative of scalar fields : IF_SCALARS_G fields (if pspscalar
(   66) !                                         present and LDSCDERS)
(   67) !   
(   68) !       Here IF_UV_G is the GLOBAL number of u/v fields as given by the length
(   69) !       of KVSETUV (or by PSPVOR if no split in spectral 'b-set' direction
(   70) !       IF_SCALARS_G is the GLOBAL number of scalar fields as giben by the 
(   71) !       length of KVESETSC (or by number of fields in PSPSCALAR if no spectral
(   72) !       'b-set' split
(   73) # 74 ".D[13]/inv_trans.h"
(   74) !     As an alternative to using PGP you can also use a combination of the
(   75) !     following arrays. The reason for introducing these alternative ways
(   76) !     of calling INV_TRANS is to avoid uneccessary copies where your data
(   77) !     structures don't fit in to the 'PSPVOR,PSPDIV, PSPSCALAR, PGP' layout.
(   78) !     The use of any of these precludes the use of PGP and vice versa.
(   79) # 80 ".D[13]/inv_trans.h"
(   80) !     PGPUV(:,:,:,:) - the 'u-v' related grid-point variables in the order
(   81) !                      described for PGP. The second dimension of PGPUV should
(   82) !                      be the same as the "global" first dimension of 
(   83) !                      PSPVOR,PSPDIV (in the IFS this is the number of levels)
(   84) !                      PGPUV need to be dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   85) !                      IFLDS is the number of 'variables' (u,v,vor,div ...)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 29

(   86) !     PGP3A(:,:,:,:) - grid-point array directly connected with PSPSC3A
(   87) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   88) !                      IFLDS is the number of 'variables' (the same as in
(   89) !                      PSPSC3A if no derivatives, 3 times that with der.)
(   90) !     PGP3B(:,:,:,:) - grid-point array directly connected with PSPSC3B
(   91) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   92) !                      IFLDS is the number of 'variables' (the same as in
(   93) !                      PSPSC3B if no derivatives, 3 times that with der.)
(   94) !     PGP2(:,:,:)    - grid-point array directly connected with PSPSC2
(   95) !                      dimensioned(NPROMA,IFLDS,NGPBLKS)
(   96) !                      IFLDS is the number of 'variables' (the same as in
(   97) !                      PSPSC2 if no derivatives, 3 times that with der.)
(   98) !     Method.
(   99) !     -------
(  100) # 101 ".D[13]/inv_trans.h"
(  101) !     Externals.  SET_RESOL   - set resolution
(  102) !     ----------  LTINV_CTL   - control of Legendre transform
(  103) !                 FTINV_CTL   - control of Fourier transform
(  104) # 105 ".D[13]/inv_trans.h"
(  105) !     Author.
(  106) !     -------
(  107) !        Mats Hamrud *ECMWF*
(  108) # 109 ".D[13]/inv_trans.h"
(  109) !     Modifications.
(  110) !     --------------
(  111) !        Original : 00-03-03
(  112) !        26-02-03 Mats Hamrud & Gabor Radnoti : modified condition for scalar fields
(  113) !                                               and derivatives (IF_SCALARS_G)
(  114) # 115 ".D[13]/inv_trans.h"
(  115) !     ------------------------------------------------------------------
(  116) # 117 ".D[13]/inv_trans.h"
(  117) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  118) # 120 ".D[13]/inv_trans.h"
(  120) IMPLICIT NONE
(  121) # 122 ".D[13]/inv_trans.h"
(  122) ! Declaration of arguments
(  123) # 124 ".D[13]/inv_trans.h"
(  124) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPVOR(:,:)
(  125) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPDIV(:,:)
(  126) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSCALAR(:,:)
(  127) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSC3A(:,:,:)
(  128) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSC3B(:,:,:)
(  129) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSC2(:,:)
(  130) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDSCDERS
(  131) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDVORGP
(  132) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDDIVGP
(  133) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDUVDER
(  134) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDLATLON
(  135) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KPROMA
(  136) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETUV(:)
(  137) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC(:)
(  138) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3A(:)
(  139) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3B(:)
(  140) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC2(:)
(  141) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KRESOL
(  142) EXTERNAL  FSPGL_PROC
(  143) OPTIONAL  FSPGL_PROC
(  144) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP(:,:,:)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 30

(  145) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGPUV(:,:,:,:)
(  146) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP3A(:,:,:,:)
(  147) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP3B(:,:,:,:)
(  148) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP2(:,:,:)
(  149) # 151 ".D[13]/inv_trans.h"
(  151) END SUBROUTINE INV_TRANS
(  152) # 153 ".D[13]/inv_trans.h"
(  153) END INTERFACE
(  154) # 57 "aatestprog.F90"
(   57) # 58 "aatestprog.F90"
(   58) # 1 ".D[9]/esetup_trans.h"
(    1) INTERFACE
(    2) SUBROUTINE ESETUP_TRANS(KMSMAX,KSMAX,KDGL,KDGUX,KLOEN,LDSPLIT,&
(    3)  & KFLEV,KTMAX,KRESOL,PEXWN,PEYWN,PWEIGHT,LDGRIDONLY,KNOEXTZL,KNOEXTZG,&
(    4)  & LDUSEFFTW)
(    5) !**** *ESETUP_TRANS* - Setup transform package for specific resolution
(    6) # 7 ".D[9]/esetup_trans.h"
(    7) !     Purpose.
(    8) !     --------
(    9) !     To setup for making spectral transforms. Each call to this routine
(   10) !     creates a new resolution up to a maximum of NMAX_RESOL set up in
(   11) !     SETUP_TRANS0. You need to call SETUP_TRANS0 before this routine can
(   12) !     be called.
(   13) # 14 ".D[9]/esetup_trans.h"
(   14) !**   Interface.
(   15) !     ----------
(   16) !     CALL ESETUP_TRANS(...)
(   17) # 18 ".D[9]/esetup_trans.h"
(   18) !     Explicit arguments : KLOEN,LDSPLIT are optional arguments
(   19) !     -------------------- 
(   20) !     KSMAX - spectral truncation required
(   21) !     KDGL  - number of Gaussian latitudes
(   22) !     KLOEN(:) - number of points on each Gaussian latitude [2*KDGL]
(   23) !     LDSPLIT - true if split latitudes in grid-point space [false]
(   24) !     KTMAX - truncation order for tendencies?
(   25) !     KRESOL - the resolution identifier
(   26) !     KSMAX,KDGL,KTMAX and KLOEN are GLOBAL variables desribing the resolution
(   27) !     in spectral and grid-point space
(   28) !     LDGRIDONLY - true if only grid space is required
(   29) # 31 ".D[9]/esetup_trans.h"
(   31) !     LDSPLIT describe the distribution among processors of
(   32) !     grid-point data and has no relevance if you are using a single processor
(   33)  
(   34) !     LDUSEFFTW   - Use FFTW for FFTs
(   35) # 36 ".D[9]/esetup_trans.h"
(   36) !     Method.
(   37) !     -------
(   38) # 39 ".D[9]/esetup_trans.h"
(   39) !     Externals.  ESET_RESOL   - set resolution
(   40) !     ----------  ESETUP_DIMS  - setup distribution independent dimensions
(   41) !                 SUEMP_TRANS_PRELEG - first part of setup of distr. environment
(   42) !                 SULEG - Compute Legandre polonomial and Gaussian 
(   43) !                         Latitudes and Weights
(   44) !                 ESETUP_GEOM - Compute arrays related to grid-point geometry
(   45) !                 SUEMP_TRANS - Second part of setup of distributed environment
(   46) !                 SUEFFT - setup for FFT
(   47) # 48 ".D[9]/esetup_trans.h"
(   48) !     Author.






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 31

(   49) !     -------
(   50) !        Mats Hamrud *ECMWF*
(   51) # 52 ".D[9]/esetup_trans.h"
(   52) !     Modifications.
(   53) !     --------------
(   54) !        Original : 00-03-03
(   55) !        02-04-11 A. Bogatchev: Passing of TCDIS
(   56) !        02-11-14 C. Fischer: soften test on KDGL
(   57) !        M.Hamrud      01-Oct-2003 CY28 Cleaning
(   58) !        A.Nmiri       15-Nov-2007 Phasing with TFL 32R3
(   59) !        A.Bogatchev   16-Sep-2010 Phasing cy37
(   60) !        D. Degrauwe  (Feb 2012): Alternative extension zone (E')
(   61) # 62 ".D[9]/esetup_trans.h"
(   62) !     ------------------------------------------------------------------
(   63) # 64 ".D[9]/esetup_trans.h"
(   64) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   65) # 66 ".D[9]/esetup_trans.h"
(   66) IMPLICIT NONE
(   67) # 68 ".D[9]/esetup_trans.h"
(   68) ! Dummy arguments
(   69) INTEGER(KIND=JPIM),INTENT(IN)    :: KMSMAX 
(   70) INTEGER(KIND=JPIM),INTENT(IN)    :: KSMAX 
(   71) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGL 
(   72) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGUX 
(   73) INTEGER(KIND=JPIM),INTENT(IN)    :: KLOEN(:) 
(   74) LOGICAL           ,OPTIONAL,INTENT(IN)    :: LDSPLIT 
(   75) LOGICAL           ,OPTIONAL,INTENT(IN)    :: LDGRIDONLY
(   76) INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN)    :: KTMAX 
(   77) INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN)    :: KFLEV
(   78) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KRESOL 
(   79) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(IN)    :: PEXWN 
(   80) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(IN)    :: PEYWN 
(   81) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(IN)    :: PWEIGHT(:)
(   82) INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN)    :: KNOEXTZL
(   83) INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN)    :: KNOEXTZG
(   84) LOGICAL   ,OPTIONAL,INTENT(IN)            :: LDUSEFFTW
(   85) # 86 ".D[9]/esetup_trans.h"
(   86) END SUBROUTINE ESETUP_TRANS
(   87) END INTERFACE
(   88) # 59 "aatestprog.F90"
(   59) # 59 "aatestprog.F90"
(   59) # 1 ".D[9]/etrans_inq.h"
(    1) INTERFACE
(    2) SUBROUTINE ETRANS_INQ(KRESOL,KSPEC,KSPEC2,KSPEC2G,KSPEC2MX,KNUMP,&
(    3)  & KGPTOT,KGPTOTG,KGPTOTMX,KGPTOTL,&
(    4)  & KMYMS,KESM0,KUMPP,KPOSSP,KPTRMS,KALLMS,KDIM0G,&
(    5)  & KFRSTLAT,KLSTLAT,KFRSTLOFF,KPTRLAT,&
(    6)  & KPTRFRSTLAT,KPTRLSTLAT,KPTRFLOFF,KSTA,KONL,&
(    7)  & KULTPP,KPTRLS,&
(    8)  & KPRTRW,KMYSETW,KMYSETV,KMY_REGION_NS,KMY_REGION_EW,&
(    9)  & LDSPLITLAT,&
(   10)  & KSMAX,KMSMAX,KNVALUE,KMVALUE,PLEPINM,KDEF_RESOL,LDLAM,&
(   11)  & PMU,PGW,PRPNM,KLEI3,KSPOLEGL,KPMS,KCPL2M,KCPL4M,KPROCM)  
(   12) # 13 ".D[9]/etrans_inq.h"
(   13) !**** *ETRANS_INQ* - Extract information from the transform package
(   14) # 15 ".D[9]/etrans_inq.h"
(   15) !     Purpose.
(   16) !     --------






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 32

(   17) !     Interface routine for extracting information from the T.P.
(   18) # 19 ".D[9]/etrans_inq.h"
(   19) !**   Interface.
(   20) !     ----------
(   21) !     CALL ETRANS_INQ(...)
(   22) !     Explicit arguments : All arguments are optional.
(   23) !     -------------------- 
(   24) !     KRESOL   - resolution tag for which info is required ,default is the
(   25) !                first defined resulution (input)
(   26) # 27 ".D[9]/etrans_inq.h"
(   27) !                   MULTI-TRANSFORMS MANAGEMENT
(   28) !     KDEF_RESOL - number or resolutions defined
(   29) !     LDLAM      - .T. if the corresponding resolution is LAM, .F. if it is global
(   30) # 31 ".D[9]/etrans_inq.h"
(   31) !                   SPECTRAL SPACE
(   32) !     KSPEC    - number of complex spectral coefficients on this PE
(   33) !     KSPEC2   - 2*KSPEC 
(   34) !     KSPEC2G  - global KSPEC2
(   35) !     KSPEC2MX - maximun KSPEC2 among all PEs
(   36) !     KNUMP    - Number of spectral waves handled by this PE
(   37) !     KGPTOT   - Total number of grid columns on this PE
(   38) !     KGPTOTG  - Total number of grid columns on the Globe
(   39) !     KGPTOTMX - Maximum number of grid columns on any of the PEs
(   40) !     KGPTOTL  - Number of grid columns one each PE (dimension N_REGIONS_NS:N_REGIONS_EW)
(   41) !     KMYMS    - This PEs spectral zonal wavenumbers
(   42) !     KESM0    - Address in a spectral array of (m, n=m)
(   43) !     KUMPP    - No. of wave numbers each wave set is responsible for
(   44) !     KPOSSP   - Defines partitioning of global spectral fields among PEs
(   45) !     KPTRMS   - Pointer to the first wave number of a given a-set
(   46) !     KALLMS   - Wave numbers for all wave-set concatenated together 
(   47) !                to give all wave numbers in wave-set order
(   48) !     KDIM0G   - Defines partitioning of global spectral fields among PEs
(   49) !     KSMAX    - spectral truncation - n direction
(   50) !     KMSMAX   - spectral truncation - m direction
(   51) !     KNVALUE  - n value for each KSPEC2 spectral coeffient
(   52) !     KMVALUE  - m value for each KSPEC2 spectral coeffient
(   53) # 54 ".D[9]/etrans_inq.h"
(   54) !                 GRIDPOINT SPACE                  
(   55) !     KFRSTLAT    - First latitude of each a-set in grid-point space
(   56) !     KLSTTLAT    - Last latitude of each a-set in grid-point space
(   57) !     KFRSTLOFF   - Offset for first lat of own a-set in grid-point space
(   58) !     KPTRLAT     - Pointer to the start of each latitude
(   59) !     KPTRFRSTLAT - Pointer to the first latitude of each a-set in 
(   60) !                   NSTA and NONL arrays
(   61) !     KPTRLSTLAT  - Pointer to the last latitude of each a-set in
(   62) !                   NSTA and NONL arrays
(   63) !     KPTRFLOFF   - Offset for pointer to the first latitude of own a-set
(   64) !                   NSTA and NONL arrays, i.e. nptrfrstlat(myseta)-1
(   65) !     KSTA        - Position of first grid column for the latitudes on a 
(   66) !                   processor. The information is available for all processors.
(   67) !                   The b-sets are distinguished by the last dimension of 
(   68) !                   nsta().The latitude band for each a-set is addressed by 
(   69) !                   nptrfrstlat(jaset),nptrlstlat(jaset), and 
(   70) !                   nptrfloff=nptrfrstlat(myseta) on this processors a-set.
(   71) !                   Each split latitude has two entries in nsta(,:) which 
(   72) !                   necessitates the rather complex addressing of nsta(,:)
(   73) !                   and the overdimensioning of nsta by N_REGIONS_NS.
(   74) !     KONL        - Number of grid columns for the latitudes on a processor.






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 33

(   75) !                   Similar to nsta() in data structure.
(   76) !     LDSPLITLAT  - TRUE if latitude is split in grid point space over 
(   77) !                   two a-sets
(   78) # 79 ".D[9]/etrans_inq.h"
(   79) !                FOURIER SPACE
(   80) !     KULTPP   - number of latitudes for which each a-set is calculating 
(   81) !                the FFT's.
(   82) !     KPTRLS   - pointer to first global latitude of each a-set for which
(   83) !                it performs the Fourier calculations
(   84) # 85 ".D[9]/etrans_inq.h"
(   85) !                 LEGENDRE
(   86) !     PMU      - sin(Gaussian latitudes)
(   87) !     PGW      - Gaussian weights
(   88) !     PRPNM    - Legendre polynomials
(   89) !     KLEI3    - First dimension of Legendre polynomials
(   90) !     KSPOLEGL - Second dimension of Legendre polynomials
(   91) !     KPMS     - Adress for legendre polynomial for given M (NSMAX)
(   92) !     PLEPINM  - Eigen-values of the inverse Laplace operator
(   93) # 94 ".D[9]/etrans_inq.h"
(   94) !     Method.
(   95) !     -------
(   96) # 97 ".D[9]/etrans_inq.h"
(   97) !     Externals.  ESET_RESOL - set resolution
(   98) !     ----------  
(   99) # 100 ".D[9]/etrans_inq.h"
(  100) !     Author.
(  101) !     -------
(  102) !        Mats Hamrud *ECMWF*
(  103) # 104 ".D[9]/etrans_inq.h"
(  104) !     Modifications.
(  105) !     --------------
(  106) !        Original : 00-03-03
(  107) !        M.Hamrud      01-Oct-2003 CY28 Cleaning
(  108) !        A.Nmiri       15-Nov-2007 Phasing with TFL 32R3
(  109) !        A.Bogatchev   16-Sep-2010 Phasing with TFL 36R4
(  110) !        R. El Khatib 08-Aug-2012 KSMAX,KMSMAX,KNVALUE,KMVALUE,PLEPINM,LDLAM,KDEF_RESOL
(  111) # 112 ".D[9]/etrans_inq.h"
(  112) !     ------------------------------------------------------------------
(  113) # 114 ".D[9]/etrans_inq.h"
(  114) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  115) # 116 ".D[9]/etrans_inq.h"
(  116) IMPLICIT NONE
(  117) # 118 ".D[9]/etrans_inq.h"
(  118) INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN)    :: KRESOL 
(  119) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC 
(  120) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC2 
(  121) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC2G 
(  122) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC2MX 
(  123) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KNUMP 
(  124) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOT 
(  125) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOTG 
(  126) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOTMX 
(  127) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOTL(:,:) 
(  128) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KMYMS(:) 
(  129) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KESM0(0:) 
(  130) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KUMPP(:) 
(  131) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPOSSP(:) 
(  132) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRMS(:) 






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 34

(  133) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KALLMS(:) 
(  134) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KDIM0G(0:) 
(  135) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KFRSTLAT(:) 
(  136) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KLSTLAT(:) 
(  137) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KFRSTLOFF 
(  138) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRLAT(:) 
(  139) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRFRSTLAT(:) 
(  140) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRLSTLAT(:) 
(  141) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRFLOFF 
(  142) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSTA(:,:) 
(  143) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KONL(:,:) 
(  144) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KULTPP(:) 
(  145) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRLS(:) 
(  146) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPRTRW
(  147) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETW
(  148) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETV
(  149) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_NS
(  150) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_EW
(  151) LOGICAL           ,OPTIONAL,INTENT(INOUT) :: LDSPLITLAT(:) 
(  152) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(INOUT) :: PMU(:) 
(  153) REAL(KIND=JPRB)   ,OPTIONAL               :: PGW(:) ! Argument NOT used
(  154) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(INOUT) :: PRPNM(:,:) 
(  155) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KLEI3 
(  156) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPOLEGL 
(  157) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPMS(0:) 
(  158) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KCPL2M(0:) 
(  159) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KCPL4M(0:) 
(  160) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPROCM(0:) 
(  161) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSMAX
(  162) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMSMAX
(  163) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNVALUE(:)
(  164) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMVALUE(:)
(  165) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(OUT) :: PLEPINM(:)
(  166) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDEF_RESOL
(  167) LOGICAL           ,OPTIONAL,INTENT(OUT)   :: LDLAM
(  168) # 169 ".D[9]/etrans_inq.h"
(  169) END SUBROUTINE ETRANS_INQ
(  170) END INTERFACE
(  171) # 60 "aatestprog.F90"
(   60) # 60 "aatestprog.F90"
(   60) # 1 ".D[9]/edist_grid.h"
(    1) INTERFACE
(    2) SUBROUTINE EDIST_GRID(PGPG,KPROMA,KFDISTG,KFROM,KRESOL,PGP,KSORT)
(    3) # 4 ".D[9]/edist_grid.h"
(    4) !**** *EDIST_GRID* - Distribute global gridpoint array among processors
(    5) # 6 ".D[9]/edist_grid.h"
(    6) !     Purpose.
(    7) !     --------
(    8) !        Interface routine for distributing gridpoint array
(    9) # 10 ".D[9]/edist_grid.h"
(   10) !**   Interface.
(   11) !     ----------
(   12) !     CALL EDIST_GRID(...)
(   13) # 14 ".D[9]/edist_grid.h"
(   14) !     Explicit arguments : 
(   15) !     -------------------- 
(   16) !     PGPG(:,:) - Global spectral array
(   17) !     KFDISTG     - Global number of fields to be distributed






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 35

(   18) !     KPROMA      - required blocking factor for gridpoint input
(   19) !     KFROM(:)    - Processor resposible for distributing each field
(   20) !     KRESOL      - resolution tag  which is required ,default is the
(   21) !                   first defined resulution (input)
(   22) !     PGP(:,:)  - Local spectral array
(   23) !
(   24) !     Method.
(   25) !     -------
(   26) # 27 ".D[9]/edist_grid.h"
(   27) !     Externals.  ESET_RESOL      - set resolution
(   28) !     ----------  DIST_GRID_CTL  - control routine
(   29) # 30 ".D[9]/edist_grid.h"
(   30) !     Author.
(   31) !     -------
(   32) !        Mats Hamrud *ECMWF*
(   33) # 34 ".D[9]/edist_grid.h"
(   34) !     Modifications.
(   35) !     --------------
(   36) !        Original : 00-03-03
(   37) # 38 ".D[9]/edist_grid.h"
(   38) !     ------------------------------------------------------------------
(   39) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   40) # 41 ".D[9]/edist_grid.h"
(   41) IMPLICIT NONE
(   42) # 43 ".D[9]/edist_grid.h"
(   43) ! Declaration of arguments
(   44) # 45 ".D[9]/edist_grid.h"
(   45) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN)  :: PGPG(:,:)
(   46) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KPROMA
(   47) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KFDISTG
(   48) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KFROM(:)
(   49) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KRESOL
(   50) REAL(KIND=JPRB)             , INTENT(OUT) :: PGP(:,:,:)
(   51) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KSORT (:)
(   52) # 54 ".D[9]/edist_grid.h"
(   54) !     ------------------------------------------------------------------
(   55) # 56 ".D[9]/edist_grid.h"
(   56) END SUBROUTINE EDIST_GRID
(   57) END INTERFACE
(   58) # 61 "aatestprog.F90"
(   61) # 61 "aatestprog.F90"
(   61) # 1 ".D[9]/egath_grid.h"
(    1) INTERFACE
(    2) SUBROUTINE EGATH_GRID(PGPG,KPROMA,KFGATHG,KTO,KRESOL,PGP)
(    3) # 4 ".D[9]/egath_grid.h"
(    4) !**** *EGATH_GRID* - Gather global gridpoint array from processors
(    5) # 6 ".D[9]/egath_grid.h"
(    6) !     Purpose.
(    7) !     --------
(    8) !        Interface routine for gathering gripoint array
(    9) # 10 ".D[9]/egath_grid.h"
(   10) !**   Interface.
(   11) !     ----------
(   12) !     CALL EGATH_GRID(...)
(   13) # 14 ".D[9]/egath_grid.h"
(   14) !     Explicit arguments : 
(   15) !     -------------------- 
(   16) !     PGPG(:,:)   - Global gridpoint array






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 36

(   17) !     KFGATHG     - Global number of fields to be gathered
(   18) !     KPROMA      - blocking factor for gridpoint input
(   19) !     KTO(:)      - Processor responsible for gathering each field
(   20) !     KRESOL      - resolution tag  which is required ,default is the
(   21) !                   first defined resulution (input)
(   22) !     PGP(:,:,:)  - Local spectral array
(   23) !
(   24) !     Method.
(   25) !     -------
(   26) # 27 ".D[9]/egath_grid.h"
(   27) !     Externals.  ESET_RESOL   - set resolution
(   28) !     ----------  GATH_GRID_CTL -  control routine
(   29) # 30 ".D[9]/egath_grid.h"
(   30) !     Author.
(   31) !     -------
(   32) !        Mats Hamrud *ECMWF*
(   33) # 34 ".D[9]/egath_grid.h"
(   34) !     Modifications.
(   35) !     --------------
(   36) !        Original : 00-03-03
(   37) # 38 ".D[9]/egath_grid.h"
(   38) !     ------------------------------------------------------------------
(   39) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   40) # 41 ".D[9]/egath_grid.h"
(   41) IMPLICIT NONE
(   42) # 43 ".D[9]/egath_grid.h"
(   43) ! Declaration of arguments
(   44) # 45 ".D[9]/egath_grid.h"
(   45) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PGPG(:,:)
(   46) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KPROMA
(   47) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KFGATHG
(   48) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KTO(:)
(   49) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KRESOL
(   50) REAL(KIND=JPRB)             , INTENT(IN)  :: PGP(:,:,:)
(   51) # 53 ".D[9]/egath_grid.h"
(   53) !     ------------------------------------------------------------------
(   54) # 55 ".D[9]/egath_grid.h"
(   55) END SUBROUTINE EGATH_GRID
(   56) END INTERFACE
(   57) # 62 "aatestprog.F90"
(   62) # 62 "aatestprog.F90"
(   62) # 1 ".D[9]/egath_spec.h"
(    1) INTERFACE
(    2) SUBROUTINE EGATH_SPEC(PSPECG,KFGATHG,KTO,KVSET,KRESOL,PSPEC,LDIM1_IS_FLD,KSMAX,KMSMAX,LDZA0IP)
(    3) # 4 ".D[9]/egath_spec.h"
(    4) !**** *EGATH_SPEC* - Gather global spectral array from processors
(    5) # 6 ".D[9]/egath_spec.h"
(    6) !     Purpose.
(    7) !     --------
(    8) !        Interface routine for gathering spectral array
(    9) # 10 ".D[9]/egath_spec.h"
(   10) !**   Interface.
(   11) !     ----------
(   12) !     CALL EGATH_SPEC(...)
(   13) # 14 ".D[9]/egath_spec.h"
(   14) !     Explicit arguments : 
(   15) !     -------------------- 
(   16) !     PSPECG(:,:) - Global spectral array






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 37

(   17) !     KFGATHG     - Global number of fields to be gathered
(   18) !     KTO(:)      - Processor responsible for gathering each field
(   19) !     KVSET(:)    - "B-Set" for each field
(   20) !     KRESOL      - resolution tag  which is required ,default is the
(   21) !                   first defined resulution (input)
(   22) !     PSPEC(:,:)  - Local spectral array
(   23) !     LDIM1_IS_FLD - If TRUE first dimension of PSCPEC and PSPECG is the field dimension [.T.]
(   24) !
(   25) !     Method.
(   26) !     -------
(   27) # 28 ".D[9]/egath_spec.h"
(   28) !     Externals.  SET_RESOL   - set resolution
(   29) !     ----------  EGATH_SPEC_CONTROL - control routine
(   30) # 31 ".D[9]/egath_spec.h"
(   31) !     Author.
(   32) !     -------
(   33) !        Mats Hamrud *ECMWF*
(   34) # 35 ".D[9]/egath_spec.h"
(   35) !     Modifications.
(   36) !     --------------
(   37) !        Original : 00-03-03
(   38) # 39 ".D[9]/egath_spec.h"
(   39) !     ------------------------------------------------------------------
(   40) # 41 ".D[9]/egath_spec.h"
(   41) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   42) # 44 ".D[9]/egath_spec.h"
(   44) IMPLICIT NONE
(   45) # 46 ".D[9]/egath_spec.h"
(   46) ! Declaration of arguments
(   47) # 48 ".D[9]/egath_spec.h"
(   48) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPECG(:,:)
(   49) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KFGATHG
(   50) INTEGER(KIND=JPIM)          , INTENT(IN)  :: KTO(:)
(   51) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KVSET(:)
(   52) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KRESOL
(   53) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN)  :: PSPEC(:,:)
(   54) LOGICAL            ,OPTIONAL, INTENT(IN)  :: LDIM1_IS_FLD
(   55) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KSMAX
(   56) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KMSMAX
(   57) LOGICAL            ,OPTIONAL, INTENT(IN)  :: LDZA0IP
(   58) # 60 ".D[9]/egath_spec.h"
(   60) !     ------------------------------------------------------------------
(   61) # 62 ".D[9]/egath_spec.h"
(   62) END SUBROUTINE EGATH_SPEC
(   63) # 64 ".D[9]/egath_spec.h"
(   64) END INTERFACE
(   65) # 63 "aatestprog.F90"
(   63) # 63 "aatestprog.F90"
(   63) # 1 ".D[9]/edir_trans.h"
(    1) INTERFACE
(    2) SUBROUTINE EDIR_TRANS(PSPVOR,PSPDIV,PSPSCALAR,PSPSC3A,PSPSC3B,PSPSC2,&
(    3) & KPROMA,KVSETUV,KVSETSC,KRESOL,KVSETSC3A,KVSETSC3B,KVSETSC2,&
(    4) & PGP,PGPUV,PGP3A,PGP3B,PGP2,PMEANU,PMEANV,AUX_PROC)
(    5) # 7 ".D[9]/edir_trans.h"
(    7) !**** *EDIR_TRANS* - Direct spectral transform (from grid-point to spectral).
(    8) # 9 ".D[9]/edir_trans.h"
(    9) !     Purpose.
(   10) !     --------






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 38

(   11) !        Interface routine for the direct spectral transform
(   12) # 13 ".D[9]/edir_trans.h"
(   13) !**   Interface.
(   14) !     ----------
(   15) !     CALL EDIR_TRANS(...)
(   16) # 17 ".D[9]/edir_trans.h"
(   17) !     Explicit arguments : All arguments except from PGP are optional.
(   18) !     --------------------
(   19) !     PSPVOR(:,:) - spectral vorticity (output)
(   20) !     PSPDIV(:,:) - spectral divergence (output)
(   21) !     PSPSCALAR(:,:) - spectral scalarvalued fields (output)
(   22) !     PSPSC3A(:,:,:) - alternative to use of PSPSCALAR, see PGP3A below (input)
(   23) !     PSPSC3B(:,:,:) - alternative to use of PSPSCALAR, see PGP3B below (input)
(   24) !     PSPSC2(:,:)  - alternative to use of PSPSCALAR, see PGP2 below (input)
(   25) !     KPROMA      - required blocking factor for gridpoint output
(   26) !     KVSETUV(:)  - indicating which 'b-set' in spectral space owns a
(   27) !                   vor/div field. Equivalant to NBSETLEV in the IFS.
(   28) !                   The length of KVSETUV should be the GLOBAL number
(   29) !                   of u/v fields which is the dimension of u and v releated
(   30) !                   fields in grid-point space.
(   31) !     KVESETSC(:) - indicating which 'b-set' in spectral space owns a
(   32) !                   scalar field. As for KVSETUV this argument is required
(   33) !                   if the total number of processors is greater than
(   34) !                   the number of processors used for distribution in
(   35) !                   spectral wave space.
(   36) !     KVSETSC3A(:) - as KVESETSC for PSPSC3A (distribution on first dimension)
(   37) !     KVSETSC3B(:) - as KVESETSC for PSPSC3B (distribution on first dimension)
(   38) !     KVSETSC2(:) - as KVESETSC for PSPSC2 (distribution on first dimension)
(   39) !     KRESOL   - resolution tag  which is required ,default is the
(   40) !                first defined resulution (input)
(   41) !     PGP(:,:,:) - gridpoint fields (input)
(   42) !                  PGP need to  dimensioned (NPROMA,IF_GP,NGPBLKS) where
(   43) !                  NPROMA is the blocking factor, IF_GP the total number
(   44) !                  of output fields and NGPBLKS the number of NPROMA blocks.
(   45) !                  The ordering of the output fields is as follows (all
(   46) !                  parts are optional depending on the input switches):
(   47) !
(   48) !     u             : IF_UV_G fields (if psvor present)
(   49) !     v             : IF_UV_G fields (if psvor present)
(   50) !     scalar fields : IF_SCALARS_G fields (if pspscalar present)
(   51) !
(   52) !     Here IF_UV_G is the GLOBAL number of u/v fields as given by the length
(   53) !     of KVSETUV (or by PSPVOR if no split in spectral 'b-set' direction
(   54) !     IF_SCALARS_G is the GLOBAL number of scalar fields as giben by the
(   55) !     length of KVESETSC (or by number of fields in PSPSCALAR if no spectral
(   56) !     'b-set' split
(   57) # 58 ".D[9]/edir_trans.h"
(   58) !     As an alternative to using PGP you can also use a combination of the
(   59) !     following arrays. The reason for introducing these alternative ways
(   60) !     of calling DIR_TRANS is to avoid uneccessary copies where your data
(   61) !     structures don't fit in to the 'PSPVOR,PSPDIV, PSPSCALAR, PGP' layout.
(   62) !     The use of any of these precludes the use of PGP and vice versa.
(   63) # 64 ".D[9]/edir_trans.h"
(   64) !     PGPUV(:,:,:,:) - the 'u-v' related grid-point variables in the order
(   65) !                      described for PGP. The second dimension of PGPUV should
(   66) !                      be the same as the "global" first dimension of
(   67) !                      PSPVOR,PSPDIV (in the IFS this is the number of levels)
(   68) !                      PGPUV need to be dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 39

(   69) !                      IFLDS is the number of 'variables' (u,v)
(   70) !     PGP3A(:,:,:,:) - grid-point array directly connected with PSPSC3A
(   71) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   72) !                      IFLDS is the number of 'variables' (the same as in
(   73) !                      PSPSC3A )
(   74) !     PGP3B(:,:,:,:) - grid-point array directly connected with PSPSC3B
(   75) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   76) !                      IFLDS is the number of 'variables' (the same as in
(   77) !                      PSPSC3B)
(   78) !     PGP2(:,:,:)    - grid-point array directly connected with PSPSC2
(   79) !                      dimensioned(NPROMA,IFLDS,NGPBLKS)
(   80) !                      IFLDS is the number of 'variables' (the same as in
(   81) !                      PSPSC2 )
(   82) !     PMEANU(:),PMEANV(:) - mean wind
(   83) !     AUX_PROC       - optional external procedure for biperiodization of
(   84) !                      aux.fields
(   85) # 86 ".D[9]/edir_trans.h"
(   86) !     Method.
(   87) !     -------
(   88) # 89 ".D[9]/edir_trans.h"
(   89) !     Externals.  SET_RESOL   - set resolution
(   90) !     ----------  LTDIR_CTL   - control of Legendre transform
(   91) !                 FTDIR_CTL   - control of Fourier transform
(   92) # 93 ".D[9]/edir_trans.h"
(   93) !     Author.
(   94) !     -------
(   95) !        Mats Hamrud *ECMWF*
(   96) # 97 ".D[9]/edir_trans.h"
(   97) !     Modifications.
(   98) !     --------------
(   99) !        Original : 00-03-03
(  100) # 101 ".D[9]/edir_trans.h"
(  101) !     ------------------------------------------------------------------
(  102) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  103) # 104 ".D[9]/edir_trans.h"
(  104) IMPLICIT NONE
(  105) # 106 ".D[9]/edir_trans.h"
(  106) ! Declaration of arguments
(  107) # 108 ".D[9]/edir_trans.h"
(  108) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPVOR(:,:)
(  109) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPDIV(:,:)
(  110) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSCALAR(:,:)
(  111) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSC3A(:,:,:)
(  112) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSC3B(:,:,:)
(  113) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSC2(:,:)
(  114) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KPROMA
(  115) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETUV(:)
(  116) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC(:)
(  117) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3A(:)
(  118) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3B(:)
(  119) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC2(:)
(  120) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KRESOL
(  121) # 122 ".D[9]/edir_trans.h"
(  122) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP(:,:,:)
(  123) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGPUV(:,:,:,:)
(  124) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP3A(:,:,:,:)
(  125) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP3B(:,:,:,:)
(  126) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP2(:,:,:)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 40

(  127) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PMEANU(:)
(  128) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PMEANV(:)
(  129) EXTERNAL AUX_PROC
(  130) OPTIONAL AUX_PROC
(  131) # 133 ".D[9]/edir_trans.h"
(  133) END SUBROUTINE EDIR_TRANS
(  134) # 135 ".D[9]/edir_trans.h"
(  135) END INTERFACE
(  136) # 64 "aatestprog.F90"
(   64) # 64 "aatestprog.F90"
(   64) # 1 ".D[9]/einv_trans.h"
(    1) INTERFACE
(    2) SUBROUTINE EINV_TRANS(PSPVOR,PSPDIV,PSPSCALAR,PSPSC3A,PSPSC3B,PSPSC2,&
(    3)  & FSPGL_PROC,&
(    4)  & LDSCDERS,LDVORGP,LDDIVGP,LDUVDER,KPROMA,KVSETUV,KVSETSC,KRESOL,&
(    5)  & KVSETSC3A,KVSETSC3B,KVSETSC2,&
(    6)  & PGP,PGPUV,PGP3A,PGP3B,PGP2,PMEANU,PMEANV)
(    7) # 8 ".D[9]/einv_trans.h"
(    8) !**** *EINV_TRANS* - Inverse spectral transform.
(    9) # 10 ".D[9]/einv_trans.h"
(   10) !     Purpose.
(   11) !     --------
(   12) !        Interface routine for the inverse spectral transform
(   13) # 14 ".D[9]/einv_trans.h"
(   14) !**   Interface.
(   15) !     ----------
(   16) !     CALL EINV_TRANS(...)
(   17) # 18 ".D[9]/einv_trans.h"
(   18) !     Explicit arguments : All arguments are optional.
(   19) !     --------------------
(   20) !     PSPVOR(:,:) - spectral vorticity (input)
(   21) !     PSPDIV(:,:) - spectral divergence (input)
(   22) !     PSPSCALAR(:,:) - spectral scalarvalued fields (input)
(   23) !     PSPSC3A(:,:,:) - alternative to use of PSPSCALAR, see PGP3A below (input)
(   24) !     PSPSC3B(:,:,:) - alternative to use of PSPSCALAR, see PGP3B below (input)
(   25) !     PSPSC2(:,:)  - alternative to use of PSPSCALAR, see PGP2 below (input)
(   26) !     FSPGL_PROC  - external procedure to be executed in fourier space
(   27) !                   before transposition
(   28) !     LDSCDERS    - indicating if derivatives of scalar variables are req.
(   29) !     LDVORGP     - indicating if grid-point vorticity is req.
(   30) !     LDDIVGP     - indicating if grid-point divergence is req.
(   31) !     LDUVDER     - indicating if E-W derivatives of u and v are req.
(   32) !     KPROMA      - required blocking factor for gridpoint output
(   33) !     KVSETUV(:)  - indicating which 'b-set' in spectral space owns a
(   34) !                   vor/div field. Equivalant to NBSETLEV in the IFS.
(   35) !                   The length of KVSETUV should be the GLOBAL number
(   36) !                   of u/v fields which is the dimension of u and v releated
(   37) !                   fields in grid-point space.
(   38) !     KVESETSC(:) - indicating which 'b-set' in spectral space owns a
(   39) !                   scalar field. As for KVSETUV this argument is required
(   40) !                   if the total number of processors is greater than
(   41) !                   the number of processors used for distribution in
(   42) !                   spectral wave space.
(   43) !     KVSETSC3A(:) - as KVESETSC for PSPSC3A (distribution on first dimension)
(   44) !     KVSETSC3B(:) - as KVESETSC for PSPSC3B (distribution on first dimension)
(   45) !     KVSETSC2(:) - as KVESETSC for PSPSC2 (distribution on first dimension)
(   46) !     KRESOL   - resolution tag  which is required ,default is the
(   47) !                first defined resulution (input)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 41

(   48) !     PGP(:,:,:) - gridpoint fields (output)
(   49) !                  PGP need to  dimensioned (NPROMA,IF_GP,NGPBLKS) where
(   50) !                  NPROMA is the blocking factor, IF_GP the total number
(   51) !                  of output fields and NGPBLKS the number of NPROMA blocks.
(   52) !                  The ordering of the output fields is as follows (all
(   53) !                  parts are optional depending on the input switches):
(   54) !
(   55) !       vorticity     : IF_UV_G fields (if psvor present and LDVORGP)
(   56) !       divergence    : IF_UV_G fields (if psvor present and LDDIVGP)
(   57) !       u             : IF_UV_G fields (if psvor present)
(   58) !       v             : IF_UV_G fields (if psvor present)
(   59) !       scalar fields : IF_SCALARS_G fields (if pspscalar present)
(   60) !       N-S derivative of scalar fields : IF_SCALARS_G fields (if pspscalar
(   61) !                                         present and LDSCDERS)
(   62) !       E-W derivative of u : IF_UV_G fields (if psvor present and and LDUVDER)
(   63) !       E-W derivative of v : IF_UV_G fields (if psvor present and and LDUVDER)
(   64) !       E-W derivative of scalar fields : IF_SCALARS_G fields (if pspscalar
(   65) !                                         present and LDSCDERS)
(   66) !
(   67) !       Here IF_UV_G is the GLOBAL number of u/v fields as given by the length
(   68) !       of KVSETUV (or by PSPVOR if no split in spectral 'b-set' direction
(   69) !       IF_SCALARS_G is the GLOBAL number of scalar fields as giben by the
(   70) !       length of KVESETSC (or by number of fields in PSPSCALAR if no spectral
(   71) !       'b-set' split
(   72) # 73 ".D[9]/einv_trans.h"
(   73) !     As an alternative to using PGP you can also use a combination of the
(   74) !     following arrays. The reason for introducing these alternative ways
(   75) !     of calling INV_TRANS is to avoid uneccessary copies where your data
(   76) !     structures don't fit in to the 'PSPVOR,PSPDIV, PSPSCALAR, PGP' layout.
(   77) !     The use of any of these precludes the use of PGP and vice versa.
(   78) # 79 ".D[9]/einv_trans.h"
(   79) !     PGPUV(:,:,:,:) - the 'u-v' related grid-point variables in the order
(   80) !                      described for PGP. The second dimension of PGPUV should
(   81) !                      be the same as the "global" first dimension of
(   82) !                      PSPVOR,PSPDIV (in the IFS this is the number of levels)
(   83) !                      PGPUV need to be dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   84) !                      IFLDS is the number of 'variables' (u,v,vor,div ...)
(   85) !     PGP3A(:,:,:,:) - grid-point array directly connected with PSPSC3A
(   86) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   87) !                      IFLDS is the number of 'variables' (the same as in
(   88) !                      PSPSC3A if no derivatives, 3 times that with der.)
(   89) !     PGP3B(:,:,:,:) - grid-point array directly connected with PSPSC3B
(   90) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   91) !                      IFLDS is the number of 'variables' (the same as in
(   92) !                      PSPSC3B if no derivatives, 3 times that with der.)
(   93) !     PGP2(:,:,:)    - grid-point array directly connected with PSPSC2
(   94) !                      dimensioned(NPROMA,IFLDS,NGPBLKS)
(   95) !                      IFLDS is the number of 'variables' (the same as in
(   96) !                      PSPSC2 if no derivatives, 3 times that with der.)
(   97) !     Method.
(   98) !     -------
(   99) # 100 ".D[9]/einv_trans.h"
(  100) !     Externals.  ESET_RESOL   - set resolution
(  101) !     ----------  ELTINV_CTL   - control of Legendre transform
(  102) !                 EFTINV_CTL   - control of Fourier transform
(  103) # 104 ".D[9]/einv_trans.h"
(  104) !     Author.
(  105) !     -------






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 42

(  106) !        Mats Hamrud *ECMWF*
(  107) # 108 ".D[9]/einv_trans.h"
(  108) !     Modifications.
(  109) !     --------------
(  110) !        Original : 00-03-03
(  111) !        26-02-03 Mats Hamrud & Gabor Radnoti : modified condition for scalar fields
(  112) !                                               and derivatives (IF_SCALARS_G)
(  113) # 114 ".D[9]/einv_trans.h"
(  114) !     ------------------------------------------------------------------
(  115) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  116) # 117 ".D[9]/einv_trans.h"
(  117) IMPLICIT NONE
(  118) # 119 ".D[9]/einv_trans.h"
(  119) ! Declaration of arguments
(  120) # 121 ".D[9]/einv_trans.h"
(  121) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPVOR(:,:)
(  122) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPDIV(:,:)
(  123) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSCALAR(:,:)
(  124) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSC3A(:,:,:)
(  125) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSC3B(:,:,:)
(  126) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSC2(:,:)
(  127) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDSCDERS
(  128) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDVORGP
(  129) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDDIVGP
(  130) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDUVDER
(  131) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KPROMA
(  132) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETUV(:)
(  133) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC(:)
(  134) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3A(:)
(  135) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3B(:)
(  136) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC2(:)
(  137) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KRESOL
(  138) EXTERNAL  FSPGL_PROC
(  139) OPTIONAL  FSPGL_PROC
(  140) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP(:,:,:)
(  141) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGPUV(:,:,:,:)
(  142) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP3A(:,:,:,:)
(  143) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP3B(:,:,:,:)
(  144) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP2(:,:,:)
(  145) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN)  :: PMEANU(:)
(  146) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN)  :: PMEANV(:)
(  147) # 149 ".D[9]/einv_trans.h"
(  149) END SUBROUTINE EINV_TRANS
(  150) # 151 ".D[9]/einv_trans.h"
(  151) END INTERFACE
(  152) # 65 "aatestprog.F90"
(   65) # 66 "aatestprog.F90"
(   66) # 1 "/gpfs7kro/gpfslocalsys/nvhpc/20.11/Linux_x86_64/20.11/comm_libs/openmpi/openmpi-3.1.5/include/mpif.h"
(    1) ! -*- fortran -*-
(    2) !
(    3) ! Copyright (c) 2004-2006 The Trustees of Indiana University and Indiana
(    4) !                         University Research and Technology
(    5) !                         Corporation.  All rights reserved.
(    6) ! Copyright (c) 2004-2005 The University of Tennessee and The University
(    7) !                         of Tennessee Research Foundation.  All rights
(    8) !                         reserved.
(    9) ! Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
(   10) !                         University of Stuttgart.  All rights reserved.






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 43

(   11) ! Copyright (c) 2004-2005 The Regents of the University of California.
(   12) !                         All rights reserved.
(   13) ! Copyright (c) 2006-2014 Cisco Systems, Inc.  All rights reserved.
(   14) ! Copyright (c) 2017      Research Organization for Information Science
(   15) !                         and Technology (RIST). All rights reserved.
(   16) ! $COPYRIGHT$
(   17) !
(   18) ! Additional copyrights may follow
(   19) !
(   20) ! $HEADER$
(   21) !
(   22) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
(   23) ! WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
(   24) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
(   25) !
(   26) ! Do ***not*** copy this file to the directory where your Fortran
(   27) ! fortran application is compiled unless it is absolutely necessary!  Most
(   28) ! modern Fortran compilers now support the -I command line flag, which
(   29) ! tells the compiler where to find .h files (specifically, this one).  For
(   30) ! example:
(   31) !
(   32) !      shell$ mpifort foo.f -o foo -I$OMPI_HOME/include
(   33) !
(   34) ! will probably do the trick (assuming that you have set OMPI_HOME
(   35) ! properly).
(   36) !
(   37) ! That being said, OMPI's "mpifort" wrapper compiler should
(   38) ! automatically include the -I option for you.  The following command
(   39) ! should be equivalent to the command listed above:
(   40) !
(   41) !      shell$ mpifort foo.f -o foo
(   42) !
(   43) ! You should not copy this file to your local directory because it is
(   44) ! possible that this file will be changed between versions of Open MPI.
(   45) ! Indeed, this mpif.h is incompatible with the mpif.f of other
(   46) ! implementations of MPI.  Using this mpif.h with other implementations
(   47) ! of MPI, or with other versions of Open MPI will result in undefined
(   48) ! behavior (to include incorrect results, segmentation faults,
(   49) ! unexplainable "hanging" in your application, etc.).  Always use the
(   50) ! -I command line option instead (or let mpifort do it for you).
(   51) !
(   52) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
(   53) ! WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
(   54) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
(   55) # 56 "/gpfs7kro/gpfslocalsys/nvhpc/20.11/Linux_x86_64/20.11/comm_libs/openmpi/openmpi-3.1.5/include/mpif.h"
(   56)       include 'mpif-config.h'
/gpfs7kro/gpfslocalsys/nvhpc/20.11/Linux_x86_64/20.11/comm_libs/openmpi/openmpi-3.1.5/include/mpif-config.h
(    1)*! -*- fortran -*-
(    2)*!
(    3)*! Copyright (c) 2004-2006 The Trustees of Indiana University and Indiana
(    4)*!                         University Research and Technology
(    5)*!                         Corporation.  All rights reserved.
(    6)*! Copyright (c) 2004-2005 The University of Tennessee and The University
(    7)*!                         of Tennessee Research Foundation.  All rights
(    8)*!                         reserved.
(    9)*! Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
(   10)*!                         University of Stuttgart.  All rights reserved.
(   11)*! Copyright (c) 2004-2005 The Regents of the University of California.






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 44

(   12)*!                         All rights reserved.
(   13)*! Copyright (c) 2006-2017 Cisco Systems, Inc.  All rights reserved
(   14)*! Copyright (c) 2013      Los Alamos National Security, LLC. All rights
(   15)*!                         reserved.
(   16)*! $COPYRIGHT$
(   17)*!
(   18)*! Additional copyrights may follow
(   19)*!
(   20)*! $HEADER$
(   21)*!
(   22)*
(   23)*!
(   24)*!     This file contains the output from configure that is relevant for
(   25)*!     Fortran applications and a few values that are necessary to
(   26)*!     compile the Fortran modules (e.g., MPI_STATUS_SIZE).
(   27)*!
(   28)*
(   29)*!
(   30)*!     OMPI version
(   31)*!     This file is generated from configure; do not edit it manually.
(   32)*!
(   33)*      integer OMPI_MAJOR_VERSION, OMPI_MINOR_VERSION
(   34)*      integer OMPI_RELEASE_VERSION
(   35)*      parameter (OMPI_MAJOR_VERSION=3)
(   36)*      parameter (OMPI_MINOR_VERSION=1)
(   37)*      parameter (OMPI_RELEASE_VERSION=5)
(   38)*!
(   39)*!     Kind parameters
(   40)*!
(   41)*      integer MPI_OFFSET_KIND, MPI_ADDRESS_KIND, MPI_INTEGER_KIND
(   42)*      integer MPI_COUNT_KIND
(   43)*      parameter (MPI_INTEGER_KIND=4)
(   44)*      parameter (MPI_ADDRESS_KIND=8)
(   45)*      parameter (MPI_OFFSET_KIND=8)
(   46)*      parameter (MPI_COUNT_KIND=8)
(   47)*!
(   48)*!     Miscellaneous constants
(   49)*!
(   50)*      integer MPI_STATUS_SIZE
(   51)*      parameter (MPI_STATUS_SIZE=6)
(   52)*!
(   53)*!     Configurable length constants
(   54)*!
(   55)*      integer MPI_MAX_PROCESSOR_NAME
(   56)*      integer MPI_MAX_ERROR_STRING
(   57)*      integer MPI_MAX_OBJECT_NAME
(   58)*      integer MPI_MAX_LIBRARY_VERSION_STRING
(   59)*      integer MPI_MAX_INFO_KEY
(   60)*      integer MPI_MAX_INFO_VAL
(   61)*      integer MPI_MAX_PORT_NAME
(   62)*      integer MPI_MAX_DATAREP_STRING
(   63)*      parameter (MPI_MAX_PROCESSOR_NAME=256-1)
(   64)*      parameter (MPI_MAX_ERROR_STRING=256-1)
(   65)*      parameter (MPI_MAX_OBJECT_NAME=64-1)
(   66)*      parameter (MPI_MAX_LIBRARY_VERSION_STRING=256-1)
(   67)*      parameter (MPI_MAX_INFO_KEY=36-1)
(   68)*      parameter (MPI_MAX_INFO_VAL=256-1)
(   69)*      parameter (MPI_MAX_PORT_NAME=1024-1)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 45

(   70)*      parameter (MPI_MAX_DATAREP_STRING=128-1)
(   71)*
(   72)*!
(   73)*! MPI F08 conformance
(   74)*!
(   75)*      logical MPI_SUBARRAYS_SUPPORTED
(   76)*      logical MPI_ASYNC_PROTECTS_NONBLOCKING
(   77)*      ! Hard-coded for .false. for now
(   78)*      parameter (MPI_SUBARRAYS_SUPPORTED= .false.)
(   79)*      ! Hard-coded for .false. for now
(   80)*      parameter (MPI_ASYNC_PROTECTS_NONBLOCKING = .false.)
(   81)*
(   57)       include 'mpif-constants.h'
/gpfs7kro/gpfslocalsys/nvhpc/20.11/Linux_x86_64/20.11/comm_libs/openmpi/openmpi-3.1.5/include/mpif-constants.h
(    1)*! -*- fortran -*-
(    2)*! WARNING! THIS IS A GENERATED FILE!!
(    3)*! ANY EDITS YOU PUT HERE WILL BE LOST!
(    4)*! ==> Instead, edit topdir/ompi/include/mpif-values.pl.
(    5)*
(    6)*! Copyright (c) 2004-2006 The Trustees of Indiana University and Indiana
(    7)*!                         University Research and Technology
(    8)*!                         Corporation.  All rights reserved.
(    9)*! Copyright (c) 2004-2010 The University of Tennessee and The University
(   10)*!                         of Tennessee Research Foundation.  All rights
(   11)*!                         reserved.
(   12)*! Copyright (c) 2004-2007 High Performance Computing Center Stuttgart,
(   13)*!                         University of Stuttgart.  All rights reserved.
(   14)*! Copyright (c) 2004-2005 The Regents of the University of California.
(   15)*!                         All rights reserved.
(   16)*! Copyright (c) 2006-2012 Cisco Systems, Inc.  All rights reserved.
(   17)*! Copyright (c) 2009      Oak Ridge National Labs.  All rights reserved.
(   18)*! Copyright (c) 2016      Research Organization for Information Science
(   19)*!                         and Technology (RIST). All rights reserved.
(   20)*! $COPYRIGHT$
(   21)*!
(   22)*! Additional copyrights may follow
(   23)*!
(   24)*! $HEADER$
(   25)*!
(   26)*
(   27)*        integer MPI_ANY_SOURCE
(   28)*        integer MPI_ANY_TAG
(   29)*        integer MPI_APPNUM
(   30)*        integer MPI_BSEND_OVERHEAD
(   31)*        integer MPI_CART
(   32)*        integer MPI_COMBINER_CONTIGUOUS
(   33)*        integer MPI_COMBINER_DARRAY
(   34)*        integer MPI_COMBINER_DUP
(   35)*        integer MPI_COMBINER_F90_COMPLEX
(   36)*        integer MPI_COMBINER_F90_INTEGER
(   37)*        integer MPI_COMBINER_F90_REAL
(   38)*        integer MPI_COMBINER_HINDEXED
(   39)*        integer MPI_COMBINER_HINDEXED_BLOCK
(   40)*        integer MPI_COMBINER_HINDEXED_INTEGER
(   41)*        integer MPI_COMBINER_HVECTOR
(   42)*        integer MPI_COMBINER_HVECTOR_INTEGER
(   43)*        integer MPI_COMBINER_INDEXED
(   44)*        integer MPI_COMBINER_INDEXED_BLOCK






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 46

(   45)*        integer MPI_COMBINER_NAMED
(   46)*        integer MPI_COMBINER_RESIZED
(   47)*        integer MPI_COMBINER_STRUCT
(   48)*        integer MPI_COMBINER_STRUCT_INTEGER
(   49)*        integer MPI_COMBINER_SUBARRAY
(   50)*        integer MPI_COMBINER_VECTOR
(   51)*        integer MPI_COMM_TYPE_SHARED
(   52)*        integer MPI_CONGRUENT
(   53)*        integer MPI_DISTRIBUTE_BLOCK
(   54)*        integer MPI_DISTRIBUTE_CYCLIC
(   55)*        integer MPI_DISTRIBUTE_DFLT_DARG
(   56)*        integer MPI_DISTRIBUTE_NONE
(   57)*        integer MPI_DIST_GRAPH
(   58)*        integer MPI_ERROR
(   59)*        integer MPI_ERR_ACCESS
(   60)*        integer MPI_ERR_AMODE
(   61)*        integer MPI_ERR_ARG
(   62)*        integer MPI_ERR_ASSERT
(   63)*        integer MPI_ERR_BAD_FILE
(   64)*        integer MPI_ERR_BASE
(   65)*        integer MPI_ERR_BUFFER
(   66)*        integer MPI_ERR_COMM
(   67)*        integer MPI_ERR_CONVERSION
(   68)*        integer MPI_ERR_COUNT
(   69)*        integer MPI_ERR_DIMS
(   70)*        integer MPI_ERR_DISP
(   71)*        integer MPI_ERR_DUP_DATAREP
(   72)*        integer MPI_ERR_FILE
(   73)*        integer MPI_ERR_FILE_EXISTS
(   74)*        integer MPI_ERR_FILE_IN_USE
(   75)*        integer MPI_ERR_GROUP
(   76)*        integer MPI_ERR_INFO
(   77)*        integer MPI_ERR_INFO_KEY
(   78)*        integer MPI_ERR_INFO_NOKEY
(   79)*        integer MPI_ERR_INFO_VALUE
(   80)*        integer MPI_ERR_INTERN
(   81)*        integer MPI_ERR_IN_STATUS
(   82)*        integer MPI_ERR_IO
(   83)*        integer MPI_ERR_KEYVAL
(   84)*        integer MPI_ERR_LASTCODE
(   85)*        integer MPI_ERR_LOCKTYPE
(   86)*        integer MPI_ERR_NAME
(   87)*        integer MPI_ERR_NOT_SAME
(   88)*        integer MPI_ERR_NO_MEM
(   89)*        integer MPI_ERR_NO_SPACE
(   90)*        integer MPI_ERR_NO_SUCH_FILE
(   91)*        integer MPI_ERR_OP
(   92)*        integer MPI_ERR_OTHER
(   93)*        integer MPI_ERR_PENDING
(   94)*        integer MPI_ERR_PORT
(   95)*        integer MPI_ERR_QUOTA
(   96)*        integer MPI_ERR_RANK
(   97)*        integer MPI_ERR_READ_ONLY
(   98)*        integer MPI_ERR_REQUEST
(   99)*        integer MPI_ERR_RMA_ATTACH
(  100)*        integer MPI_ERR_RMA_CONFLICT
(  101)*        integer MPI_ERR_RMA_FLAVOR
(  102)*        integer MPI_ERR_RMA_RANGE






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 47

(  103)*        integer MPI_ERR_RMA_SHARED
(  104)*        integer MPI_ERR_RMA_SYNC
(  105)*        integer MPI_ERR_ROOT
(  106)*        integer MPI_ERR_SERVICE
(  107)*        integer MPI_ERR_SIZE
(  108)*        integer MPI_ERR_SPAWN
(  109)*        integer MPI_ERR_TAG
(  110)*        integer MPI_ERR_TOPOLOGY
(  111)*        integer MPI_ERR_TRUNCATE
(  112)*        integer MPI_ERR_TYPE
(  113)*        integer MPI_ERR_UNKNOWN
(  114)*        integer MPI_ERR_UNSUPPORTED_DATAREP
(  115)*        integer MPI_ERR_UNSUPPORTED_OPERATION
(  116)*        integer MPI_ERR_WIN
(  117)*        integer MPI_GRAPH
(  118)*        integer MPI_HOST
(  119)*        integer MPI_IDENT
(  120)*        integer MPI_IO
(  121)*        integer MPI_KEYVAL_INVALID
(  122)*        integer MPI_LASTUSEDCODE
(  123)*        integer MPI_LOCK_EXCLUSIVE
(  124)*        integer MPI_LOCK_SHARED
(  125)*        integer MPI_MODE_NOCHECK
(  126)*        integer MPI_MODE_NOPRECEDE
(  127)*        integer MPI_MODE_NOPUT
(  128)*        integer MPI_MODE_NOSTORE
(  129)*        integer MPI_MODE_NOSUCCEED
(  130)*        integer MPI_ORDER_C
(  131)*        integer MPI_ORDER_FORTRAN
(  132)*        integer MPI_PROC_NULL
(  133)*        integer MPI_ROOT
(  134)*        integer MPI_SIMILAR
(  135)*        integer MPI_SOURCE
(  136)*        integer MPI_SUBVERSION
(  137)*        integer MPI_SUCCESS
(  138)*        integer MPI_TAG
(  139)*        integer MPI_TAG_UB
(  140)*        integer MPI_THREAD_FUNNELED
(  141)*        integer MPI_THREAD_MULTIPLE
(  142)*        integer MPI_THREAD_SERIALIZED
(  143)*        integer MPI_THREAD_SINGLE
(  144)*        integer MPI_TYPECLASS_COMPLEX
(  145)*        integer MPI_TYPECLASS_INTEGER
(  146)*        integer MPI_TYPECLASS_REAL
(  147)*        integer MPI_T_ERR_CANNOT_INIT
(  148)*        integer MPI_T_ERR_CVAR_SET_NEVER
(  149)*        integer MPI_T_ERR_CVAR_SET_NOT_NOW
(  150)*        integer MPI_T_ERR_INVALID
(  151)*        integer MPI_T_ERR_INVALID_HANDLE
(  152)*        integer MPI_T_ERR_INVALID_INDEX
(  153)*        integer MPI_T_ERR_INVALID_ITEM
(  154)*        integer MPI_T_ERR_INVALID_SESSION
(  155)*        integer MPI_T_ERR_MEMORY
(  156)*        integer MPI_T_ERR_NOT_INITIALIZED
(  157)*        integer MPI_T_ERR_OUT_OF_HANDLES
(  158)*        integer MPI_T_ERR_OUT_OF_SESSIONS
(  159)*        integer MPI_T_ERR_PVAR_NO_ATOMIC
(  160)*        integer MPI_T_ERR_PVAR_NO_STARTSTOP






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 48

(  161)*        integer MPI_T_ERR_PVAR_NO_WRITE
(  162)*        integer MPI_UNDEFINED
(  163)*        integer MPI_UNEQUAL
(  164)*        integer MPI_UNIVERSE_SIZE
(  165)*        integer MPI_VERSION
(  166)*        integer MPI_WIN_BASE
(  167)*        integer MPI_WIN_CREATE_FLAVOR
(  168)*        integer MPI_WIN_DISP_UNIT
(  169)*        integer MPI_WIN_FLAVOR_ALLOCATE
(  170)*        integer MPI_WIN_FLAVOR_CREATE
(  171)*        integer MPI_WIN_FLAVOR_DYNAMIC
(  172)*        integer MPI_WIN_FLAVOR_SHARED
(  173)*        integer MPI_WIN_MODEL
(  174)*        integer MPI_WIN_SEPARATE
(  175)*        integer MPI_WIN_SIZE
(  176)*        integer MPI_WIN_UNIFIED
(  177)*        integer MPI_WTIME_IS_GLOBAL
(  178)*        integer OMPI_COMM_TYPE_BOARD
(  179)*        integer OMPI_COMM_TYPE_CLUSTER
(  180)*        integer OMPI_COMM_TYPE_CORE
(  181)*        integer OMPI_COMM_TYPE_CU
(  182)*        integer OMPI_COMM_TYPE_HOST
(  183)*        integer OMPI_COMM_TYPE_HWTHREAD
(  184)*        integer OMPI_COMM_TYPE_L1CACHE
(  185)*        integer OMPI_COMM_TYPE_L2CACHE
(  186)*        integer OMPI_COMM_TYPE_L3CACHE
(  187)*        integer OMPI_COMM_TYPE_NODE
(  188)*        integer OMPI_COMM_TYPE_NUMA
(  189)*        integer OMPI_COMM_TYPE_SOCKET
(  190)*
(  191)*        parameter (MPI_ANY_SOURCE=-1)
(  192)*        parameter (MPI_ANY_TAG=-1)
(  193)*        parameter (MPI_APPNUM=4)
(  194)*        parameter (MPI_BSEND_OVERHEAD=128)
(  195)*        parameter (MPI_CART=1)
(  196)*        parameter (MPI_COMBINER_CONTIGUOUS=2)
(  197)*        parameter (MPI_COMBINER_DARRAY=13)
(  198)*        parameter (MPI_COMBINER_DUP=1)
(  199)*        parameter (MPI_COMBINER_F90_COMPLEX=15)
(  200)*        parameter (MPI_COMBINER_F90_INTEGER=16)
(  201)*        parameter (MPI_COMBINER_F90_REAL=14)
(  202)*        parameter (MPI_COMBINER_HINDEXED=8)
(  203)*        parameter (MPI_COMBINER_HINDEXED_BLOCK=18)
(  204)*        parameter (MPI_COMBINER_HINDEXED_INTEGER=7)
(  205)*        parameter (MPI_COMBINER_HVECTOR=5)
(  206)*        parameter (MPI_COMBINER_HVECTOR_INTEGER=4)
(  207)*        parameter (MPI_COMBINER_INDEXED=6)
(  208)*        parameter (MPI_COMBINER_INDEXED_BLOCK=9)
(  209)*        parameter (MPI_COMBINER_NAMED=0)
(  210)*        parameter (MPI_COMBINER_RESIZED=17)
(  211)*        parameter (MPI_COMBINER_STRUCT=11)
(  212)*        parameter (MPI_COMBINER_STRUCT_INTEGER=10)
(  213)*        parameter (MPI_COMBINER_SUBARRAY=12)
(  214)*        parameter (MPI_COMBINER_VECTOR=3)
(  215)*        parameter (MPI_COMM_TYPE_SHARED=0)
(  216)*        parameter (MPI_CONGRUENT=1)
(  217)*        parameter (MPI_DISTRIBUTE_BLOCK=0)
(  218)*        parameter (MPI_DISTRIBUTE_CYCLIC=1)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 49

(  219)*        parameter (MPI_DISTRIBUTE_DFLT_DARG=-1)
(  220)*        parameter (MPI_DISTRIBUTE_NONE=2)
(  221)*        parameter (MPI_DIST_GRAPH=3)
(  222)*        parameter (MPI_ERROR=3)
(  223)*        parameter (MPI_ERR_ACCESS=20)
(  224)*        parameter (MPI_ERR_AMODE=21)
(  225)*        parameter (MPI_ERR_ARG=13)
(  226)*        parameter (MPI_ERR_ASSERT=22)
(  227)*        parameter (MPI_ERR_BAD_FILE=23)
(  228)*        parameter (MPI_ERR_BASE=24)
(  229)*        parameter (MPI_ERR_BUFFER=1)
(  230)*        parameter (MPI_ERR_COMM=5)
(  231)*        parameter (MPI_ERR_CONVERSION=25)
(  232)*        parameter (MPI_ERR_COUNT=2)
(  233)*        parameter (MPI_ERR_DIMS=12)
(  234)*        parameter (MPI_ERR_DISP=26)
(  235)*        parameter (MPI_ERR_DUP_DATAREP=27)
(  236)*        parameter (MPI_ERR_FILE=30)
(  237)*        parameter (MPI_ERR_FILE_EXISTS=28)
(  238)*        parameter (MPI_ERR_FILE_IN_USE=29)
(  239)*        parameter (MPI_ERR_GROUP=9)
(  240)*        parameter (MPI_ERR_INFO=34)
(  241)*        parameter (MPI_ERR_INFO_KEY=31)
(  242)*        parameter (MPI_ERR_INFO_NOKEY=32)
(  243)*        parameter (MPI_ERR_INFO_VALUE=33)
(  244)*        parameter (MPI_ERR_INTERN=17)
(  245)*        parameter (MPI_ERR_IN_STATUS=18)
(  246)*        parameter (MPI_ERR_IO=35)
(  247)*        parameter (MPI_ERR_KEYVAL=36)
(  248)*        parameter (MPI_ERR_LASTCODE=92)
(  249)*        parameter (MPI_ERR_LOCKTYPE=37)
(  250)*        parameter (MPI_ERR_NAME=38)
(  251)*        parameter (MPI_ERR_NOT_SAME=40)
(  252)*        parameter (MPI_ERR_NO_MEM=39)
(  253)*        parameter (MPI_ERR_NO_SPACE=41)
(  254)*        parameter (MPI_ERR_NO_SUCH_FILE=42)
(  255)*        parameter (MPI_ERR_OP=10)
(  256)*        parameter (MPI_ERR_OTHER=16)
(  257)*        parameter (MPI_ERR_PENDING=19)
(  258)*        parameter (MPI_ERR_PORT=43)
(  259)*        parameter (MPI_ERR_QUOTA=44)
(  260)*        parameter (MPI_ERR_RANK=6)
(  261)*        parameter (MPI_ERR_READ_ONLY=45)
(  262)*        parameter (MPI_ERR_REQUEST=7)
(  263)*        parameter (MPI_ERR_RMA_ATTACH=69)
(  264)*        parameter (MPI_ERR_RMA_CONFLICT=46)
(  265)*        parameter (MPI_ERR_RMA_FLAVOR=70)
(  266)*        parameter (MPI_ERR_RMA_RANGE=68)
(  267)*        parameter (MPI_ERR_RMA_SHARED=71)
(  268)*        parameter (MPI_ERR_RMA_SYNC=47)
(  269)*        parameter (MPI_ERR_ROOT=8)
(  270)*        parameter (MPI_ERR_SERVICE=48)
(  271)*        parameter (MPI_ERR_SIZE=49)
(  272)*        parameter (MPI_ERR_SPAWN=50)
(  273)*        parameter (MPI_ERR_TAG=4)
(  274)*        parameter (MPI_ERR_TOPOLOGY=11)
(  275)*        parameter (MPI_ERR_TRUNCATE=15)
(  276)*        parameter (MPI_ERR_TYPE=3)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 50

(  277)*        parameter (MPI_ERR_UNKNOWN=14)
(  278)*        parameter (MPI_ERR_UNSUPPORTED_DATAREP=51)
(  279)*        parameter (MPI_ERR_UNSUPPORTED_OPERATION=52)
(  280)*        parameter (MPI_ERR_WIN=53)
(  281)*        parameter (MPI_GRAPH=2)
(  282)*        parameter (MPI_HOST=1)
(  283)*        parameter (MPI_IDENT=0)
(  284)*        parameter (MPI_IO=2)
(  285)*        parameter (MPI_KEYVAL_INVALID=-1)
(  286)*        parameter (MPI_LASTUSEDCODE=5)
(  287)*        parameter (MPI_LOCK_EXCLUSIVE=1)
(  288)*        parameter (MPI_LOCK_SHARED=2)
(  289)*        parameter (MPI_MODE_NOCHECK=1)
(  290)*        parameter (MPI_MODE_NOPRECEDE=2)
(  291)*        parameter (MPI_MODE_NOPUT=4)
(  292)*        parameter (MPI_MODE_NOSTORE=8)
(  293)*        parameter (MPI_MODE_NOSUCCEED=16)
(  294)*        parameter (MPI_ORDER_C=0)
(  295)*        parameter (MPI_ORDER_FORTRAN=1)
(  296)*        parameter (MPI_PROC_NULL=-2)
(  297)*        parameter (MPI_ROOT=-4)
(  298)*        parameter (MPI_SIMILAR=2)
(  299)*        parameter (MPI_SOURCE=1)
(  300)*        parameter (MPI_SUBVERSION=1)
(  301)*        parameter (MPI_SUCCESS=0)
(  302)*        parameter (MPI_TAG=2)
(  303)*        parameter (MPI_TAG_UB=0)
(  304)*        parameter (MPI_THREAD_FUNNELED=1)
(  305)*        parameter (MPI_THREAD_MULTIPLE=3)
(  306)*        parameter (MPI_THREAD_SERIALIZED=2)
(  307)*        parameter (MPI_THREAD_SINGLE=0)
(  308)*        parameter (MPI_TYPECLASS_COMPLEX=3)
(  309)*        parameter (MPI_TYPECLASS_INTEGER=1)
(  310)*        parameter (MPI_TYPECLASS_REAL=2)
(  311)*        parameter (MPI_T_ERR_CANNOT_INIT=56)
(  312)*        parameter (MPI_T_ERR_CVAR_SET_NEVER=64)
(  313)*        parameter (MPI_T_ERR_CVAR_SET_NOT_NOW=63)
(  314)*        parameter (MPI_T_ERR_INVALID=72)
(  315)*        parameter (MPI_T_ERR_INVALID_HANDLE=59)
(  316)*        parameter (MPI_T_ERR_INVALID_INDEX=57)
(  317)*        parameter (MPI_T_ERR_INVALID_ITEM=58)
(  318)*        parameter (MPI_T_ERR_INVALID_SESSION=62)
(  319)*        parameter (MPI_T_ERR_MEMORY=54)
(  320)*        parameter (MPI_T_ERR_NOT_INITIALIZED=55)
(  321)*        parameter (MPI_T_ERR_OUT_OF_HANDLES=60)
(  322)*        parameter (MPI_T_ERR_OUT_OF_SESSIONS=61)
(  323)*        parameter (MPI_T_ERR_PVAR_NO_ATOMIC=67)
(  324)*        parameter (MPI_T_ERR_PVAR_NO_STARTSTOP=65)
(  325)*        parameter (MPI_T_ERR_PVAR_NO_WRITE=66)
(  326)*        parameter (MPI_UNDEFINED=-32766)
(  327)*        parameter (MPI_UNEQUAL=3)
(  328)*        parameter (MPI_UNIVERSE_SIZE=6)
(  329)*        parameter (MPI_VERSION=3)
(  330)*        parameter (MPI_WIN_BASE=7)
(  331)*        parameter (MPI_WIN_CREATE_FLAVOR=10)
(  332)*        parameter (MPI_WIN_DISP_UNIT=9)
(  333)*        parameter (MPI_WIN_FLAVOR_ALLOCATE=2)
(  334)*        parameter (MPI_WIN_FLAVOR_CREATE=1)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 51

(  335)*        parameter (MPI_WIN_FLAVOR_DYNAMIC=3)
(  336)*        parameter (MPI_WIN_FLAVOR_SHARED=4)
(  337)*        parameter (MPI_WIN_MODEL=11)
(  338)*        parameter (MPI_WIN_SEPARATE=1)
(  339)*        parameter (MPI_WIN_SIZE=8)
(  340)*        parameter (MPI_WIN_UNIFIED=0)
(  341)*        parameter (MPI_WTIME_IS_GLOBAL=3)
(  342)*        parameter (OMPI_COMM_TYPE_BOARD=8)
(  343)*        parameter (OMPI_COMM_TYPE_CLUSTER=11)
(  344)*        parameter (OMPI_COMM_TYPE_CORE=2)
(  345)*        parameter (OMPI_COMM_TYPE_CU=10)
(  346)*        parameter (OMPI_COMM_TYPE_HOST=9)
(  347)*        parameter (OMPI_COMM_TYPE_HWTHREAD=1)
(  348)*        parameter (OMPI_COMM_TYPE_L1CACHE=3)
(  349)*        parameter (OMPI_COMM_TYPE_L2CACHE=4)
(  350)*        parameter (OMPI_COMM_TYPE_L3CACHE=5)
(  351)*        parameter (OMPI_COMM_TYPE_NODE=0)
(  352)*        parameter (OMPI_COMM_TYPE_NUMA=7)
(  353)*        parameter (OMPI_COMM_TYPE_SOCKET=6)
(   58)       include 'mpif-handles.h'
/gpfs7kro/gpfslocalsys/nvhpc/20.11/Linux_x86_64/20.11/comm_libs/openmpi/openmpi-3.1.5/include/mpif-handles.h
(    1)*! -*- fortran -*-
(    2)*! WARNING! THIS IS A GENERATED FILE!!
(    3)*! ANY EDITS YOU PUT HERE WILL BE LOST!
(    4)*! ==> Instead, edit topdir/ompi/include/mpif-values.pl.
(    5)*
(    6)*! Copyright (c) 2004-2006 The Trustees of Indiana University and Indiana
(    7)*!                         University Research and Technology
(    8)*!                         Corporation.  All rights reserved.
(    9)*! Copyright (c) 2004-2010 The University of Tennessee and The University
(   10)*!                         of Tennessee Research Foundation.  All rights
(   11)*!                         reserved.
(   12)*! Copyright (c) 2004-2007 High Performance Computing Center Stuttgart,
(   13)*!                         University of Stuttgart.  All rights reserved.
(   14)*! Copyright (c) 2004-2005 The Regents of the University of California.
(   15)*!                         All rights reserved.
(   16)*! Copyright (c) 2006-2012 Cisco Systems, Inc.  All rights reserved.
(   17)*! Copyright (c) 2009      Oak Ridge National Labs.  All rights reserved.
(   18)*! Copyright (c) 2016      Research Organization for Information Science
(   19)*!                         and Technology (RIST). All rights reserved.
(   20)*! $COPYRIGHT$
(   21)*!
(   22)*! Additional copyrights may follow
(   23)*!
(   24)*! $HEADER$
(   25)*!
(   26)*
(   27)*        integer MPI_2COMPLEX
(   28)*        integer MPI_2DOUBLE_COMPLEX
(   29)*        integer MPI_2DOUBLE_PRECISION
(   30)*        integer MPI_2INT
(   31)*        integer MPI_2INTEGER
(   32)*        integer MPI_2REAL
(   33)*        integer MPI_AINT
(   34)*        integer MPI_BAND
(   35)*        integer MPI_BOR
(   36)*        integer MPI_BXOR
(   37)*        integer MPI_BYTE






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 52

(   38)*        integer MPI_CHAR
(   39)*        integer MPI_CHARACTER
(   40)*        integer MPI_COMM_NULL
(   41)*        integer MPI_COMM_SELF
(   42)*        integer MPI_COMM_WORLD
(   43)*        integer MPI_COMPLEX
(   44)*        integer MPI_COMPLEX16
(   45)*        integer MPI_COMPLEX32
(   46)*        integer MPI_COMPLEX8
(   47)*        integer MPI_COUNT
(   48)*        integer MPI_CXX_BOOL
(   49)*        integer MPI_CXX_COMPLEX
(   50)*        integer MPI_CXX_DOUBLE_COMPLEX
(   51)*        integer MPI_CXX_FLOAT_COMPLEX
(   52)*        integer MPI_CXX_LONG_DOUBLE_COMPLEX
(   53)*        integer MPI_C_BOOL
(   54)*        integer MPI_C_COMPLEX
(   55)*        integer MPI_C_DOUBLE_COMPLEX
(   56)*        integer MPI_C_FLOAT_COMPLEX
(   57)*        integer MPI_C_LONG_DOUBLE_COMPLEX
(   58)*        integer MPI_DATATYPE_NULL
(   59)*        integer MPI_DOUBLE
(   60)*        integer MPI_DOUBLE_COMPLEX
(   61)*        integer MPI_DOUBLE_INT
(   62)*        integer MPI_DOUBLE_PRECISION
(   63)*        integer MPI_ERRHANDLER_NULL
(   64)*        integer MPI_ERRORS_ARE_FATAL
(   65)*        integer MPI_ERRORS_RETURN
(   66)*        integer MPI_FLOAT
(   67)*        integer MPI_FLOAT_INT
(   68)*        integer MPI_GROUP_EMPTY
(   69)*        integer MPI_GROUP_NULL
(   70)*        integer MPI_INFO_ENV
(   71)*        integer MPI_INFO_NULL
(   72)*        integer MPI_INT
(   73)*        integer MPI_INT16_T
(   74)*        integer MPI_INT32_T
(   75)*        integer MPI_INT64_T
(   76)*        integer MPI_INT8_T
(   77)*        integer MPI_INTEGER
(   78)*        integer MPI_INTEGER1
(   79)*        integer MPI_INTEGER16
(   80)*        integer MPI_INTEGER2
(   81)*        integer MPI_INTEGER4
(   82)*        integer MPI_INTEGER8
(   83)*        integer MPI_LAND
(   84)*        integer MPI_LB
(   85)*        integer MPI_LOGICAL
(   86)*        integer MPI_LOGICAL1
(   87)*        integer MPI_LOGICAL2
(   88)*        integer MPI_LOGICAL4
(   89)*        integer MPI_LOGICAL8
(   90)*        integer MPI_LONG
(   91)*        integer MPI_LONG_DOUBLE
(   92)*        integer MPI_LONG_DOUBLE_INT
(   93)*        integer MPI_LONG_INT
(   94)*        integer MPI_LONG_LONG
(   95)*        integer MPI_LONG_LONG_INT






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 53

(   96)*        integer MPI_LOR
(   97)*        integer MPI_LXOR
(   98)*        integer MPI_MAX
(   99)*        integer MPI_MAXLOC
(  100)*        integer MPI_MESSAGE_NO_PROC
(  101)*        integer MPI_MESSAGE_NULL
(  102)*        integer MPI_MIN
(  103)*        integer MPI_MINLOC
(  104)*        integer MPI_NO_OP
(  105)*        integer MPI_OFFSET
(  106)*        integer MPI_OP_NULL
(  107)*        integer MPI_PACKED
(  108)*        integer MPI_PROD
(  109)*        integer MPI_REAL
(  110)*        integer MPI_REAL16
(  111)*        integer MPI_REAL2
(  112)*        integer MPI_REAL4
(  113)*        integer MPI_REAL8
(  114)*        integer MPI_REPLACE
(  115)*        integer MPI_REQUEST_NULL
(  116)*        integer MPI_SHORT
(  117)*        integer MPI_SHORT_INT
(  118)*        integer MPI_SIGNED_CHAR
(  119)*        integer MPI_SUM
(  120)*        integer MPI_UB
(  121)*        integer MPI_UINT16_T
(  122)*        integer MPI_UINT32_T
(  123)*        integer MPI_UINT64_T
(  124)*        integer MPI_UINT8_T
(  125)*        integer MPI_UNSIGNED
(  126)*        integer MPI_UNSIGNED_CHAR
(  127)*        integer MPI_UNSIGNED_LONG
(  128)*        integer MPI_UNSIGNED_LONG_LONG
(  129)*        integer MPI_UNSIGNED_SHORT
(  130)*        integer MPI_WCHAR
(  131)*        integer MPI_WIN_NULL
(  132)*
(  133)*        parameter (MPI_2COMPLEX=26)
(  134)*        parameter (MPI_2DOUBLE_COMPLEX=27)
(  135)*        parameter (MPI_2DOUBLE_PRECISION=24)
(  136)*        parameter (MPI_2INT=52)
(  137)*        parameter (MPI_2INTEGER=25)
(  138)*        parameter (MPI_2REAL=23)
(  139)*        parameter (MPI_AINT=66)
(  140)*        parameter (MPI_BAND=6)
(  141)*        parameter (MPI_BOR=8)
(  142)*        parameter (MPI_BXOR=10)
(  143)*        parameter (MPI_BYTE=1)
(  144)*        parameter (MPI_CHAR=34)
(  145)*        parameter (MPI_CHARACTER=5)
(  146)*        parameter (MPI_COMM_NULL=2)
(  147)*        parameter (MPI_COMM_SELF=1)
(  148)*        parameter (MPI_COMM_WORLD=0)
(  149)*        parameter (MPI_COMPLEX=18)
(  150)*        parameter (MPI_COMPLEX16=20)
(  151)*        parameter (MPI_COMPLEX32=21)
(  152)*        parameter (MPI_COMPLEX8=19)
(  153)*        parameter (MPI_COUNT=72)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 54

(  154)*        parameter (MPI_CXX_BOOL=54)
(  155)*        parameter (MPI_CXX_COMPLEX=55)
(  156)*        parameter (MPI_CXX_DOUBLE_COMPLEX=56)
(  157)*        parameter (MPI_CXX_FLOAT_COMPLEX=55)
(  158)*        parameter (MPI_CXX_LONG_DOUBLE_COMPLEX=57)
(  159)*        parameter (MPI_C_BOOL=68)
(  160)*        parameter (MPI_C_COMPLEX=69)
(  161)*        parameter (MPI_C_DOUBLE_COMPLEX=70)
(  162)*        parameter (MPI_C_FLOAT_COMPLEX=69)
(  163)*        parameter (MPI_C_LONG_DOUBLE_COMPLEX=71)
(  164)*        parameter (MPI_DATATYPE_NULL=0)
(  165)*        parameter (MPI_DOUBLE=46)
(  166)*        parameter (MPI_DOUBLE_COMPLEX=22)
(  167)*        parameter (MPI_DOUBLE_INT=49)
(  168)*        parameter (MPI_DOUBLE_PRECISION=17)
(  169)*        parameter (MPI_ERRHANDLER_NULL=0)
(  170)*        parameter (MPI_ERRORS_ARE_FATAL=1)
(  171)*        parameter (MPI_ERRORS_RETURN=2)
(  172)*        parameter (MPI_FLOAT=45)
(  173)*        parameter (MPI_FLOAT_INT=48)
(  174)*        parameter (MPI_GROUP_EMPTY=1)
(  175)*        parameter (MPI_GROUP_NULL=0)
(  176)*        parameter (MPI_INFO_ENV=1)
(  177)*        parameter (MPI_INFO_NULL=0)
(  178)*        parameter (MPI_INT=39)
(  179)*        parameter (MPI_INT16_T=60)
(  180)*        parameter (MPI_INT32_T=62)
(  181)*        parameter (MPI_INT64_T=64)
(  182)*        parameter (MPI_INT8_T=58)
(  183)*        parameter (MPI_INTEGER=7)
(  184)*        parameter (MPI_INTEGER1=8)
(  185)*        parameter (MPI_INTEGER16=12)
(  186)*        parameter (MPI_INTEGER2=9)
(  187)*        parameter (MPI_INTEGER4=10)
(  188)*        parameter (MPI_INTEGER8=11)
(  189)*        parameter (MPI_LAND=5)
(  190)*        parameter (MPI_LB=4)
(  191)*        parameter (MPI_LOGICAL=6)
(  192)*        parameter (MPI_LOGICAL1=29)
(  193)*        parameter (MPI_LOGICAL2=30)
(  194)*        parameter (MPI_LOGICAL4=31)
(  195)*        parameter (MPI_LOGICAL8=32)
(  196)*        parameter (MPI_LONG=41)
(  197)*        parameter (MPI_LONG_DOUBLE=47)
(  198)*        parameter (MPI_LONG_DOUBLE_INT=50)
(  199)*        parameter (MPI_LONG_INT=51)
(  200)*        parameter (MPI_LONG_LONG=43)
(  201)*        parameter (MPI_LONG_LONG_INT=43)
(  202)*        parameter (MPI_LOR=7)
(  203)*        parameter (MPI_LXOR=9)
(  204)*        parameter (MPI_MAX=1)
(  205)*        parameter (MPI_MAXLOC=11)
(  206)*        parameter (MPI_MESSAGE_NO_PROC=1)
(  207)*        parameter (MPI_MESSAGE_NULL=0)
(  208)*        parameter (MPI_MIN=2)
(  209)*        parameter (MPI_MINLOC=12)
(  210)*        parameter (MPI_NO_OP=14)
(  211)*        parameter (MPI_OFFSET=67)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 55

(  212)*        parameter (MPI_OP_NULL=0)
(  213)*        parameter (MPI_PACKED=2)
(  214)*        parameter (MPI_PROD=4)
(  215)*        parameter (MPI_REAL=13)
(  216)*        parameter (MPI_REAL16=16)
(  217)*        parameter (MPI_REAL2=28)
(  218)*        parameter (MPI_REAL4=14)
(  219)*        parameter (MPI_REAL8=15)
(  220)*        parameter (MPI_REPLACE=13)
(  221)*        parameter (MPI_REQUEST_NULL=0)
(  222)*        parameter (MPI_SHORT=37)
(  223)*        parameter (MPI_SHORT_INT=53)
(  224)*        parameter (MPI_SIGNED_CHAR=36)
(  225)*        parameter (MPI_SUM=3)
(  226)*        parameter (MPI_UB=3)
(  227)*        parameter (MPI_UINT16_T=61)
(  228)*        parameter (MPI_UINT32_T=63)
(  229)*        parameter (MPI_UINT64_T=65)
(  230)*        parameter (MPI_UINT8_T=59)
(  231)*        parameter (MPI_UNSIGNED=40)
(  232)*        parameter (MPI_UNSIGNED_CHAR=35)
(  233)*        parameter (MPI_UNSIGNED_LONG=42)
(  234)*        parameter (MPI_UNSIGNED_LONG_LONG=44)
(  235)*        parameter (MPI_UNSIGNED_SHORT=38)
(  236)*        parameter (MPI_WCHAR=33)
(  237)*        parameter (MPI_WIN_NULL=0)
(   59)       include 'mpif-io-constants.h'
/gpfs7kro/gpfslocalsys/nvhpc/20.11/Linux_x86_64/20.11/comm_libs/openmpi/openmpi-3.1.5/include/mpif-io-constants.h
(    1)*! -*- fortran -*-
(    2)*! WARNING! THIS IS A GENERATED FILE!!
(    3)*! ANY EDITS YOU PUT HERE WILL BE LOST!
(    4)*! ==> Instead, edit topdir/ompi/include/mpif-values.pl.
(    5)*
(    6)*! Copyright (c) 2004-2006 The Trustees of Indiana University and Indiana
(    7)*!                         University Research and Technology
(    8)*!                         Corporation.  All rights reserved.
(    9)*! Copyright (c) 2004-2010 The University of Tennessee and The University
(   10)*!                         of Tennessee Research Foundation.  All rights
(   11)*!                         reserved.
(   12)*! Copyright (c) 2004-2007 High Performance Computing Center Stuttgart,
(   13)*!                         University of Stuttgart.  All rights reserved.
(   14)*! Copyright (c) 2004-2005 The Regents of the University of California.
(   15)*!                         All rights reserved.
(   16)*! Copyright (c) 2006-2012 Cisco Systems, Inc.  All rights reserved.
(   17)*! Copyright (c) 2009      Oak Ridge National Labs.  All rights reserved.
(   18)*! Copyright (c) 2016      Research Organization for Information Science
(   19)*!                         and Technology (RIST). All rights reserved.
(   20)*! $COPYRIGHT$
(   21)*!
(   22)*! Additional copyrights may follow
(   23)*!
(   24)*! $HEADER$
(   25)*!
(   26)*
(   27)*        integer MPI_MODE_APPEND
(   28)*        integer MPI_MODE_CREATE
(   29)*        integer MPI_MODE_DELETE_ON_CLOSE
(   30)*        integer MPI_MODE_EXCL






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 56

(   31)*        integer MPI_MODE_RDONLY
(   32)*        integer MPI_MODE_RDWR
(   33)*        integer MPI_MODE_SEQUENTIAL
(   34)*        integer MPI_MODE_UNIQUE_OPEN
(   35)*        integer MPI_MODE_WRONLY
(   36)*        integer MPI_SEEK_CUR
(   37)*        integer MPI_SEEK_END
(   38)*        integer MPI_SEEK_SET
(   39)*        integer(KIND=MPI_OFFSET_KIND) MPI_DISPLACEMENT_CURRENT
(   40)*
(   41)*        parameter (MPI_MODE_APPEND=128)
(   42)*        parameter (MPI_MODE_CREATE=1)
(   43)*        parameter (MPI_MODE_DELETE_ON_CLOSE=16)
(   44)*        parameter (MPI_MODE_EXCL=64)
(   45)*        parameter (MPI_MODE_RDONLY=2)
(   46)*        parameter (MPI_MODE_RDWR=8)
(   47)*        parameter (MPI_MODE_SEQUENTIAL=256)
(   48)*        parameter (MPI_MODE_UNIQUE_OPEN=32)
(   49)*        parameter (MPI_MODE_WRONLY=4)
(   50)*        parameter (MPI_SEEK_CUR=602)
(   51)*        parameter (MPI_SEEK_END=604)
(   52)*        parameter (MPI_SEEK_SET=600)
(   53)*        parameter (MPI_DISPLACEMENT_CURRENT=-54278278)
(   60)       include 'mpif-io-handles.h'
/gpfs7kro/gpfslocalsys/nvhpc/20.11/Linux_x86_64/20.11/comm_libs/openmpi/openmpi-3.1.5/include/mpif-io-handles.h
(    1)*! -*- fortran -*-
(    2)*! WARNING! THIS IS A GENERATED FILE!!
(    3)*! ANY EDITS YOU PUT HERE WILL BE LOST!
(    4)*! ==> Instead, edit topdir/ompi/include/mpif-values.pl.
(    5)*
(    6)*! Copyright (c) 2004-2006 The Trustees of Indiana University and Indiana
(    7)*!                         University Research and Technology
(    8)*!                         Corporation.  All rights reserved.
(    9)*! Copyright (c) 2004-2010 The University of Tennessee and The University
(   10)*!                         of Tennessee Research Foundation.  All rights
(   11)*!                         reserved.
(   12)*! Copyright (c) 2004-2007 High Performance Computing Center Stuttgart,
(   13)*!                         University of Stuttgart.  All rights reserved.
(   14)*! Copyright (c) 2004-2005 The Regents of the University of California.
(   15)*!                         All rights reserved.
(   16)*! Copyright (c) 2006-2012 Cisco Systems, Inc.  All rights reserved.
(   17)*! Copyright (c) 2009      Oak Ridge National Labs.  All rights reserved.
(   18)*! Copyright (c) 2016      Research Organization for Information Science
(   19)*!                         and Technology (RIST). All rights reserved.
(   20)*! $COPYRIGHT$
(   21)*!
(   22)*! Additional copyrights may follow
(   23)*!
(   24)*! $HEADER$
(   25)*!
(   26)*
(   27)*        integer MPI_FILE_NULL
(   28)*
(   29)*        parameter (MPI_FILE_NULL=0)
(   61)       include 'mpif-externals.h'
/gpfs7kro/gpfslocalsys/nvhpc/20.11/Linux_x86_64/20.11/comm_libs/openmpi/openmpi-3.1.5/include/mpif-externals.h
(    1)*! -*- fortran -*-
(    2)*!






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 57

(    3)*! Copyright (c) 2004-2006 The Trustees of Indiana University and Indiana
(    4)*!                         University Research and Technology
(    5)*!                         Corporation.  All rights reserved.
(    6)*! Copyright (c) 2004-2005 The University of Tennessee and The University
(    7)*!                         of Tennessee Research Foundation.  All rights
(    8)*!                         reserved.
(    9)*! Copyright (c) 2004-2005 High Performance Computing Center Stuttgart,
(   10)*!                         University of Stuttgart.  All rights reserved.
(   11)*! Copyright (c) 2004-2005 The Regents of the University of California.
(   12)*!                         All rights reserved.
(   13)*! Copyright (c) 2006-2017 Cisco Systems, Inc.  All rights reserved
(   14)*! $COPYRIGHT$
(   15)*!
(   16)*! Additional copyrights may follow
(   17)*!
(   18)*! $HEADER$
(   19)*!
(   20)*
(   21)*!
(   22)*!     These "external" statements are specific to the MPI mpif.h
(   23)*!     interface (and are toxic to the MPI module interfaces),.
(   24)*!
(   25)*      external MPI_NULL_COPY_FN, MPI_NULL_DELETE_FN
(   26)*      external MPI_COMM_NULL_COPY_FN, MPI_COMM_NULL_DELETE_FN
(   27)*      external MPI_TYPE_NULL_COPY_FN, MPI_TYPE_NULL_DELETE_FN
(   28)*      external MPI_DUP_FN, MPI_COMM_DUP_FN, MPI_TYPE_DUP_FN
(   29)*      external MPI_WIN_NULL_COPY_FN
(   30)*      external MPI_WIN_NULL_DELETE_FN
(   31)*      external MPI_WIN_DUP_FN
(   32)*!     Note that MPI_CONVERSION_FN_NULL is a "constant" (it is only ever
(   33)*!     checked for comparison; it is never invoked), but it is passed as
(   34)*!     a function pointer (to MPI_REGISTER_DATAREP) and therefore must be
(   35)*!     the same size/type.  It is therefore external'ed here, and not
(   36)*!     defined with an integer value in mpif-common.h.
(   37)*      external MPI_CONVERSION_FN_NULL
(   38)*
(   39)*!
(   40)*!     double precision functions
(   41)*!
(   42)*      external MPI_WTIME, MPI_WTICK , PMPI_WTICK, PMPI_WTIME
(   43)*      double precision MPI_WTIME, MPI_WTICK , PMPI_WTICK, PMPI_WTIME
(   44)*!
(   45)*!     address integer functions
(   46)*!
(   47)*      external MPI_AINT_ADD, MPI_AINT_DIFF
(   48)*      integer(kind=MPI_ADDRESS_KIND) MPI_AINT_ADD, MPI_AINT_DIFF
(   62)       include 'mpif-sentinels.h'
/gpfs7kro/gpfslocalsys/nvhpc/20.11/Linux_x86_64/20.11/comm_libs/openmpi/openmpi-3.1.5/include/mpif-sentinels.h
(    1)*! -*- fortran -*-
(    2)*!
(    3)*! Copyright (c) 2004-2006 The Trustees of Indiana University and Indiana
(    4)*!                         University Research and Technology
(    5)*!                         Corporation.  All rights reserved.
(    6)*! Copyright (c) 2004-2010 The University of Tennessee and The University
(    7)*!                         of Tennessee Research Foundation.  All rights
(    8)*!                         reserved.
(    9)*! Copyright (c) 2004-2007 High Performance Computing Center Stuttgart,
(   10)*!                         University of Stuttgart.  All rights reserved.






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 58

(   11)*! Copyright (c) 2004-2005 The Regents of the University of California.
(   12)*!                         All rights reserved.
(   13)*! Copyright (c) 2006-2012 Cisco Systems, Inc.  All rights reserved.
(   14)*! Copyright (c) 2009      Oak Ridge National Labs.  All rights reserved.
(   15)*! $COPYRIGHT$
(   16)*!
(   17)*! Additional copyrights may follow
(   18)*!
(   19)*! $HEADER$
(   20)*!
(   21)*
(   22)*!
(   23)*!     All of these types were chosen with care to match the types of
(   24)*!     their corresponding C variables.  Do not arbitrarily change
(   25)*!     their types without also updating:
(   26)*!
(   27)*!     - the "mpi" module bindings
(   28)*!     - the "mpi_f08" module bindings
(   29)*!     - ompi/mpi/fortran/base/gen-mpi-mangling.pl
(   30)*!
(   31)*
(   32)*!     MPI_BOTTOM is only used where choice buffers can be used (meaning
(   33)*!     that we already have overloaded F90 bindings for all available
(   34)*!     types), so any type is fine.
(   35)*      integer MPI_BOTTOM
(   36)*!     MPI_IN_PLACE has the same rationale as MPI_BOTTOM.
(   37)*      integer MPI_IN_PLACE
(   38)*!     Making MPI_ARGV_NULL be the same type as the parameter that is
(   39)*!     exepected in the F90 binding for MPI_COMM_SPAWN means that we
(   40)*!     don't need another interface for MPI_COMM_SPAWN.
(   41)*      character MPI_ARGV_NULL(1)
(   42)*!     Ditto for MPI_ARGVS_NULL / MPI_COMM_SPAWN_MULTIPLE.
(   43)*      character MPI_ARGVS_NULL(1, 1)
(   44)*!     MPI_ERRCODES_IGNORE has similar rationale to MPI_ARGV_NULL.  The
(   45)*!     F77 functions are all smart enough to check that the errcodes
(   46)*!     parameter is not ERRCODES_IGNORE before assigning values into it
(   47)*!     (hence, the fact that this is an array of only 1 element does not
(   48)*!     matter -- we'll never overrun it because we never assign values
(   49)*!     into it).
(   50)*      integer MPI_ERRCODES_IGNORE(1)
(   51)*!     MPI_STATUS_IGNORE has similar rationale to MPI_ERRCODES_IGNORE.
(   52)*      integer MPI_STATUS_IGNORE(MPI_STATUS_SIZE)
(   53)*!     Ditto for MPI_STATUSES_IGNORE
(   54)*      integer MPI_STATUSES_IGNORE(MPI_STATUS_SIZE, 1)
(   55)*!     Ditto for MPI_UNWEIGHTED
(   56)*      integer MPI_UNWEIGHTED(1)
(   57)*!     Ditto for MPI_WEIGHTS_EMPTY
(   58)*      integer MPI_WEIGHTS_EMPTY(1)
(   59)*
(   60)*      common/mpi_fortran_bottom/MPI_BOTTOM
(   61)*      common/mpi_fortran_in_place/MPI_IN_PLACE
(   62)*      common/mpi_fortran_argv_null/MPI_ARGV_NULL
(   63)*      common/mpi_fortran_argvs_null/MPI_ARGVS_NULL
(   64)*      common/mpi_fortran_errcodes_ignore/MPI_ERRCODES_IGNORE
(   65)*      common/mpi_fortran_status_ignore/MPI_STATUS_IGNORE
(   66)*      common/mpi_fortran_statuses_ignore/MPI_STATUSES_IGNORE
(   67)*      common/mpi_fortran_unweighted/MPI_UNWEIGHTED
(   68)*      common/mpi_fortran_weights_empty/MPI_WEIGHTS_EMPTY






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 59

(   63)       include 'mpif-sizeof.h'
(   64) # 67 "aatestprog.F90"
(   67) # 69 "aatestprog.F90"
(   69) # 1 ".D[12]/abor1.intfb.h"
/gpfs7kro/gpfslocalsys/nvhpc/20.11/Linux_x86_64/20.11/comm_libs/openmpi/openmpi-3.1.5/include/mpif-sizeof.h
(    1)*! -*- f90 -*-
(    2)*! WARNING: This is a generated file!  Edits will be lost!
(    3)*!
(    4)*! Copyright (c) 2014 Cisco Systems, Inc.  All rights reserved.
(    5)*! $COPYRIGHT$
(    6)*!
(    7)*! This file was generated by gen-mpi-sizeof.pl for all the MPI_SIZEOF
(    8)*! interface possibilities for intrinsic types.  Once TS 29113 is
(    9)*! supported in all compilers, we can simply have *one* procedure for
(   10)*! each type and use dimension(..) to indicate scalars+all array ranks.
(   11)*! But until more compilers support this, we simply generate a
(   12)*! procedure for scalars and all possible ranks in an attempt to
(   13)*! support lots of Fortran compilers.
(   14)*
(   15)*      INTERFACE MPI_Sizeof
(   16)*
(   17)*      SUBROUTINE MPI_Sizeof_character_scalar(x, size, ierror)
(   18)*      CHARACTER::x
(   19)*        INTEGER, INTENT(OUT) :: size
(   20)*        INTEGER, INTENT(OUT) :: ierror
(   21)*      END SUBROUTINE MPI_Sizeof_character_scalar
(   22)*
(   23)*      SUBROUTINE MPI_Sizeof_character_r1(x, size, ierror)
(   24)*      CHARACTER, DIMENSION(*)::x
(   25)*        INTEGER, INTENT(OUT) :: size
(   26)*        INTEGER, INTENT(OUT) :: ierror
(   27)*      END SUBROUTINE MPI_Sizeof_character_r1
(   28)*
(   29)*      SUBROUTINE MPI_Sizeof_character_r2(x, size, ierror)
(   30)*      CHARACTER, DIMENSION(1,*)::x
(   31)*        INTEGER, INTENT(OUT) :: size
(   32)*        INTEGER, INTENT(OUT) :: ierror
(   33)*      END SUBROUTINE MPI_Sizeof_character_r2
(   34)*
(   35)*      SUBROUTINE MPI_Sizeof_character_r3(x, size, ierror)
(   36)*      CHARACTER, DIMENSION(1,1,*)::x
(   37)*        INTEGER, INTENT(OUT) :: size
(   38)*        INTEGER, INTENT(OUT) :: ierror
(   39)*      END SUBROUTINE MPI_Sizeof_character_r3
(   40)*
(   41)*      SUBROUTINE MPI_Sizeof_character_r4(x, size, ierror)
(   42)*      CHARACTER, DIMENSION(1,1,1,*)::x
(   43)*        INTEGER, INTENT(OUT) :: size
(   44)*        INTEGER, INTENT(OUT) :: ierror
(   45)*      END SUBROUTINE MPI_Sizeof_character_r4
(   46)*
(   47)*      SUBROUTINE MPI_Sizeof_character_r5(x, size, ierror)
(   48)*      CHARACTER, DIMENSION(1,1,1,1,*)::x
(   49)*        INTEGER, INTENT(OUT) :: size
(   50)*        INTEGER, INTENT(OUT) :: ierror
(   51)*      END SUBROUTINE MPI_Sizeof_character_r5
(   52)*
(   53)*      SUBROUTINE MPI_Sizeof_character_r6(x, size, ierror)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 60

(   54)*      CHARACTER, DIMENSION(1,1,1,1,1,*)::x
(   55)*        INTEGER, INTENT(OUT) :: size
(   56)*        INTEGER, INTENT(OUT) :: ierror
(   57)*      END SUBROUTINE MPI_Sizeof_character_r6
(   58)*
(   59)*      SUBROUTINE MPI_Sizeof_character_r7(x, size, ierror)
(   60)*      CHARACTER, DIMENSION(1,1,1,1,1,1,*)::x
(   61)*        INTEGER, INTENT(OUT) :: size
(   62)*        INTEGER, INTENT(OUT) :: ierror
(   63)*      END SUBROUTINE MPI_Sizeof_character_r7
(   64)*
(   65)*      SUBROUTINE MPI_Sizeof_complex32_scalar(x, size, ierror)
(   66)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(   67)*      COMPLEX(REAL32)::x
(   68)*        INTEGER, INTENT(OUT) :: size
(   69)*        INTEGER, INTENT(OUT) :: ierror
(   70)*      END SUBROUTINE MPI_Sizeof_complex32_scalar
(   71)*
(   72)*      SUBROUTINE MPI_Sizeof_complex32_r1(x, size, ierror)
(   73)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(   74)*      COMPLEX(REAL32), DIMENSION(*)::x
(   75)*        INTEGER, INTENT(OUT) :: size
(   76)*        INTEGER, INTENT(OUT) :: ierror
(   77)*      END SUBROUTINE MPI_Sizeof_complex32_r1
(   78)*
(   79)*      SUBROUTINE MPI_Sizeof_complex32_r2(x, size, ierror)
(   80)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(   81)*      COMPLEX(REAL32), DIMENSION(1,*)::x
(   82)*        INTEGER, INTENT(OUT) :: size
(   83)*        INTEGER, INTENT(OUT) :: ierror
(   84)*      END SUBROUTINE MPI_Sizeof_complex32_r2
(   85)*
(   86)*      SUBROUTINE MPI_Sizeof_complex32_r3(x, size, ierror)
(   87)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(   88)*      COMPLEX(REAL32), DIMENSION(1,1,*)::x
(   89)*        INTEGER, INTENT(OUT) :: size
(   90)*        INTEGER, INTENT(OUT) :: ierror
(   91)*      END SUBROUTINE MPI_Sizeof_complex32_r3
(   92)*
(   93)*      SUBROUTINE MPI_Sizeof_complex32_r4(x, size, ierror)
(   94)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(   95)*      COMPLEX(REAL32), DIMENSION(1,1,1,*)::x
(   96)*        INTEGER, INTENT(OUT) :: size
(   97)*        INTEGER, INTENT(OUT) :: ierror
(   98)*      END SUBROUTINE MPI_Sizeof_complex32_r4
(   99)*
(  100)*      SUBROUTINE MPI_Sizeof_complex32_r5(x, size, ierror)
(  101)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  102)*      COMPLEX(REAL32), DIMENSION(1,1,1,1,*)::x
(  103)*        INTEGER, INTENT(OUT) :: size
(  104)*        INTEGER, INTENT(OUT) :: ierror
(  105)*      END SUBROUTINE MPI_Sizeof_complex32_r5
(  106)*
(  107)*      SUBROUTINE MPI_Sizeof_complex32_r6(x, size, ierror)
(  108)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  109)*      COMPLEX(REAL32), DIMENSION(1,1,1,1,1,*)::x
(  110)*        INTEGER, INTENT(OUT) :: size
(  111)*        INTEGER, INTENT(OUT) :: ierror






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 61

(  112)*      END SUBROUTINE MPI_Sizeof_complex32_r6
(  113)*
(  114)*      SUBROUTINE MPI_Sizeof_complex32_r7(x, size, ierror)
(  115)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  116)*      COMPLEX(REAL32), DIMENSION(1,1,1,1,1,1,*)::x
(  117)*        INTEGER, INTENT(OUT) :: size
(  118)*        INTEGER, INTENT(OUT) :: ierror
(  119)*      END SUBROUTINE MPI_Sizeof_complex32_r7
(  120)*
(  121)*      SUBROUTINE MPI_Sizeof_complex64_scalar(x, size, ierror)
(  122)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  123)*      COMPLEX(REAL64)::x
(  124)*        INTEGER, INTENT(OUT) :: size
(  125)*        INTEGER, INTENT(OUT) :: ierror
(  126)*      END SUBROUTINE MPI_Sizeof_complex64_scalar
(  127)*
(  128)*      SUBROUTINE MPI_Sizeof_complex64_r1(x, size, ierror)
(  129)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  130)*      COMPLEX(REAL64), DIMENSION(*)::x
(  131)*        INTEGER, INTENT(OUT) :: size
(  132)*        INTEGER, INTENT(OUT) :: ierror
(  133)*      END SUBROUTINE MPI_Sizeof_complex64_r1
(  134)*
(  135)*      SUBROUTINE MPI_Sizeof_complex64_r2(x, size, ierror)
(  136)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  137)*      COMPLEX(REAL64), DIMENSION(1,*)::x
(  138)*        INTEGER, INTENT(OUT) :: size
(  139)*        INTEGER, INTENT(OUT) :: ierror
(  140)*      END SUBROUTINE MPI_Sizeof_complex64_r2
(  141)*
(  142)*      SUBROUTINE MPI_Sizeof_complex64_r3(x, size, ierror)
(  143)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  144)*      COMPLEX(REAL64), DIMENSION(1,1,*)::x
(  145)*        INTEGER, INTENT(OUT) :: size
(  146)*        INTEGER, INTENT(OUT) :: ierror
(  147)*      END SUBROUTINE MPI_Sizeof_complex64_r3
(  148)*
(  149)*      SUBROUTINE MPI_Sizeof_complex64_r4(x, size, ierror)
(  150)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  151)*      COMPLEX(REAL64), DIMENSION(1,1,1,*)::x
(  152)*        INTEGER, INTENT(OUT) :: size
(  153)*        INTEGER, INTENT(OUT) :: ierror
(  154)*      END SUBROUTINE MPI_Sizeof_complex64_r4
(  155)*
(  156)*      SUBROUTINE MPI_Sizeof_complex64_r5(x, size, ierror)
(  157)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  158)*      COMPLEX(REAL64), DIMENSION(1,1,1,1,*)::x
(  159)*        INTEGER, INTENT(OUT) :: size
(  160)*        INTEGER, INTENT(OUT) :: ierror
(  161)*      END SUBROUTINE MPI_Sizeof_complex64_r5
(  162)*
(  163)*      SUBROUTINE MPI_Sizeof_complex64_r6(x, size, ierror)
(  164)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  165)*      COMPLEX(REAL64), DIMENSION(1,1,1,1,1,*)::x
(  166)*        INTEGER, INTENT(OUT) :: size
(  167)*        INTEGER, INTENT(OUT) :: ierror
(  168)*      END SUBROUTINE MPI_Sizeof_complex64_r6
(  169)*






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 62

(  170)*      SUBROUTINE MPI_Sizeof_complex64_r7(x, size, ierror)
(  171)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  172)*      COMPLEX(REAL64), DIMENSION(1,1,1,1,1,1,*)::x
(  173)*        INTEGER, INTENT(OUT) :: size
(  174)*        INTEGER, INTENT(OUT) :: ierror
(  175)*      END SUBROUTINE MPI_Sizeof_complex64_r7
(  176)*
(  177)*      SUBROUTINE MPI_Sizeof_int16_scalar(x, size, ierror)
(  178)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT16
(  179)*      INTEGER(INT16)::x
(  180)*        INTEGER, INTENT(OUT) :: size
(  181)*        INTEGER, INTENT(OUT) :: ierror
(  182)*      END SUBROUTINE MPI_Sizeof_int16_scalar
(  183)*
(  184)*      SUBROUTINE MPI_Sizeof_int16_r1(x, size, ierror)
(  185)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT16
(  186)*      INTEGER(INT16), DIMENSION(*)::x
(  187)*        INTEGER, INTENT(OUT) :: size
(  188)*        INTEGER, INTENT(OUT) :: ierror
(  189)*      END SUBROUTINE MPI_Sizeof_int16_r1
(  190)*
(  191)*      SUBROUTINE MPI_Sizeof_int16_r2(x, size, ierror)
(  192)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT16
(  193)*      INTEGER(INT16), DIMENSION(1,*)::x
(  194)*        INTEGER, INTENT(OUT) :: size
(  195)*        INTEGER, INTENT(OUT) :: ierror
(  196)*      END SUBROUTINE MPI_Sizeof_int16_r2
(  197)*
(  198)*      SUBROUTINE MPI_Sizeof_int16_r3(x, size, ierror)
(  199)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT16
(  200)*      INTEGER(INT16), DIMENSION(1,1,*)::x
(  201)*        INTEGER, INTENT(OUT) :: size
(  202)*        INTEGER, INTENT(OUT) :: ierror
(  203)*      END SUBROUTINE MPI_Sizeof_int16_r3
(  204)*
(  205)*      SUBROUTINE MPI_Sizeof_int16_r4(x, size, ierror)
(  206)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT16
(  207)*      INTEGER(INT16), DIMENSION(1,1,1,*)::x
(  208)*        INTEGER, INTENT(OUT) :: size
(  209)*        INTEGER, INTENT(OUT) :: ierror
(  210)*      END SUBROUTINE MPI_Sizeof_int16_r4
(  211)*
(  212)*      SUBROUTINE MPI_Sizeof_int16_r5(x, size, ierror)
(  213)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT16
(  214)*      INTEGER(INT16), DIMENSION(1,1,1,1,*)::x
(  215)*        INTEGER, INTENT(OUT) :: size
(  216)*        INTEGER, INTENT(OUT) :: ierror
(  217)*      END SUBROUTINE MPI_Sizeof_int16_r5
(  218)*
(  219)*      SUBROUTINE MPI_Sizeof_int16_r6(x, size, ierror)
(  220)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT16
(  221)*      INTEGER(INT16), DIMENSION(1,1,1,1,1,*)::x
(  222)*        INTEGER, INTENT(OUT) :: size
(  223)*        INTEGER, INTENT(OUT) :: ierror
(  224)*      END SUBROUTINE MPI_Sizeof_int16_r6
(  225)*
(  226)*      SUBROUTINE MPI_Sizeof_int16_r7(x, size, ierror)
(  227)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT16






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 63

(  228)*      INTEGER(INT16), DIMENSION(1,1,1,1,1,1,*)::x
(  229)*        INTEGER, INTENT(OUT) :: size
(  230)*        INTEGER, INTENT(OUT) :: ierror
(  231)*      END SUBROUTINE MPI_Sizeof_int16_r7
(  232)*
(  233)*      SUBROUTINE MPI_Sizeof_int32_scalar(x, size, ierror)
(  234)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT32
(  235)*      INTEGER(INT32)::x
(  236)*        INTEGER, INTENT(OUT) :: size
(  237)*        INTEGER, INTENT(OUT) :: ierror
(  238)*      END SUBROUTINE MPI_Sizeof_int32_scalar
(  239)*
(  240)*      SUBROUTINE MPI_Sizeof_int32_r1(x, size, ierror)
(  241)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT32
(  242)*      INTEGER(INT32), DIMENSION(*)::x
(  243)*        INTEGER, INTENT(OUT) :: size
(  244)*        INTEGER, INTENT(OUT) :: ierror
(  245)*      END SUBROUTINE MPI_Sizeof_int32_r1
(  246)*
(  247)*      SUBROUTINE MPI_Sizeof_int32_r2(x, size, ierror)
(  248)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT32
(  249)*      INTEGER(INT32), DIMENSION(1,*)::x
(  250)*        INTEGER, INTENT(OUT) :: size
(  251)*        INTEGER, INTENT(OUT) :: ierror
(  252)*      END SUBROUTINE MPI_Sizeof_int32_r2
(  253)*
(  254)*      SUBROUTINE MPI_Sizeof_int32_r3(x, size, ierror)
(  255)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT32
(  256)*      INTEGER(INT32), DIMENSION(1,1,*)::x
(  257)*        INTEGER, INTENT(OUT) :: size
(  258)*        INTEGER, INTENT(OUT) :: ierror
(  259)*      END SUBROUTINE MPI_Sizeof_int32_r3
(  260)*
(  261)*      SUBROUTINE MPI_Sizeof_int32_r4(x, size, ierror)
(  262)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT32
(  263)*      INTEGER(INT32), DIMENSION(1,1,1,*)::x
(  264)*        INTEGER, INTENT(OUT) :: size
(  265)*        INTEGER, INTENT(OUT) :: ierror
(  266)*      END SUBROUTINE MPI_Sizeof_int32_r4
(  267)*
(  268)*      SUBROUTINE MPI_Sizeof_int32_r5(x, size, ierror)
(  269)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT32
(  270)*      INTEGER(INT32), DIMENSION(1,1,1,1,*)::x
(  271)*        INTEGER, INTENT(OUT) :: size
(  272)*        INTEGER, INTENT(OUT) :: ierror
(  273)*      END SUBROUTINE MPI_Sizeof_int32_r5
(  274)*
(  275)*      SUBROUTINE MPI_Sizeof_int32_r6(x, size, ierror)
(  276)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT32
(  277)*      INTEGER(INT32), DIMENSION(1,1,1,1,1,*)::x
(  278)*        INTEGER, INTENT(OUT) :: size
(  279)*        INTEGER, INTENT(OUT) :: ierror
(  280)*      END SUBROUTINE MPI_Sizeof_int32_r6
(  281)*
(  282)*      SUBROUTINE MPI_Sizeof_int32_r7(x, size, ierror)
(  283)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT32
(  284)*      INTEGER(INT32), DIMENSION(1,1,1,1,1,1,*)::x
(  285)*        INTEGER, INTENT(OUT) :: size






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 64

(  286)*        INTEGER, INTENT(OUT) :: ierror
(  287)*      END SUBROUTINE MPI_Sizeof_int32_r7
(  288)*
(  289)*      SUBROUTINE MPI_Sizeof_int64_scalar(x, size, ierror)
(  290)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT64
(  291)*      INTEGER(INT64)::x
(  292)*        INTEGER, INTENT(OUT) :: size
(  293)*        INTEGER, INTENT(OUT) :: ierror
(  294)*      END SUBROUTINE MPI_Sizeof_int64_scalar
(  295)*
(  296)*      SUBROUTINE MPI_Sizeof_int64_r1(x, size, ierror)
(  297)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT64
(  298)*      INTEGER(INT64), DIMENSION(*)::x
(  299)*        INTEGER, INTENT(OUT) :: size
(  300)*        INTEGER, INTENT(OUT) :: ierror
(  301)*      END SUBROUTINE MPI_Sizeof_int64_r1
(  302)*
(  303)*      SUBROUTINE MPI_Sizeof_int64_r2(x, size, ierror)
(  304)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT64
(  305)*      INTEGER(INT64), DIMENSION(1,*)::x
(  306)*        INTEGER, INTENT(OUT) :: size
(  307)*        INTEGER, INTENT(OUT) :: ierror
(  308)*      END SUBROUTINE MPI_Sizeof_int64_r2
(  309)*
(  310)*      SUBROUTINE MPI_Sizeof_int64_r3(x, size, ierror)
(  311)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT64
(  312)*      INTEGER(INT64), DIMENSION(1,1,*)::x
(  313)*        INTEGER, INTENT(OUT) :: size
(  314)*        INTEGER, INTENT(OUT) :: ierror
(  315)*      END SUBROUTINE MPI_Sizeof_int64_r3
(  316)*
(  317)*      SUBROUTINE MPI_Sizeof_int64_r4(x, size, ierror)
(  318)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT64
(  319)*      INTEGER(INT64), DIMENSION(1,1,1,*)::x
(  320)*        INTEGER, INTENT(OUT) :: size
(  321)*        INTEGER, INTENT(OUT) :: ierror
(  322)*      END SUBROUTINE MPI_Sizeof_int64_r4
(  323)*
(  324)*      SUBROUTINE MPI_Sizeof_int64_r5(x, size, ierror)
(  325)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT64
(  326)*      INTEGER(INT64), DIMENSION(1,1,1,1,*)::x
(  327)*        INTEGER, INTENT(OUT) :: size
(  328)*        INTEGER, INTENT(OUT) :: ierror
(  329)*      END SUBROUTINE MPI_Sizeof_int64_r5
(  330)*
(  331)*      SUBROUTINE MPI_Sizeof_int64_r6(x, size, ierror)
(  332)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT64
(  333)*      INTEGER(INT64), DIMENSION(1,1,1,1,1,*)::x
(  334)*        INTEGER, INTENT(OUT) :: size
(  335)*        INTEGER, INTENT(OUT) :: ierror
(  336)*      END SUBROUTINE MPI_Sizeof_int64_r6
(  337)*
(  338)*      SUBROUTINE MPI_Sizeof_int64_r7(x, size, ierror)
(  339)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT64
(  340)*      INTEGER(INT64), DIMENSION(1,1,1,1,1,1,*)::x
(  341)*        INTEGER, INTENT(OUT) :: size
(  342)*        INTEGER, INTENT(OUT) :: ierror
(  343)*      END SUBROUTINE MPI_Sizeof_int64_r7






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 65

(  344)*
(  345)*      SUBROUTINE MPI_Sizeof_int8_scalar(x, size, ierror)
(  346)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT8
(  347)*      INTEGER(INT8)::x
(  348)*        INTEGER, INTENT(OUT) :: size
(  349)*        INTEGER, INTENT(OUT) :: ierror
(  350)*      END SUBROUTINE MPI_Sizeof_int8_scalar
(  351)*
(  352)*      SUBROUTINE MPI_Sizeof_int8_r1(x, size, ierror)
(  353)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT8
(  354)*      INTEGER(INT8), DIMENSION(*)::x
(  355)*        INTEGER, INTENT(OUT) :: size
(  356)*        INTEGER, INTENT(OUT) :: ierror
(  357)*      END SUBROUTINE MPI_Sizeof_int8_r1
(  358)*
(  359)*      SUBROUTINE MPI_Sizeof_int8_r2(x, size, ierror)
(  360)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT8
(  361)*      INTEGER(INT8), DIMENSION(1,*)::x
(  362)*        INTEGER, INTENT(OUT) :: size
(  363)*        INTEGER, INTENT(OUT) :: ierror
(  364)*      END SUBROUTINE MPI_Sizeof_int8_r2
(  365)*
(  366)*      SUBROUTINE MPI_Sizeof_int8_r3(x, size, ierror)
(  367)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT8
(  368)*      INTEGER(INT8), DIMENSION(1,1,*)::x
(  369)*        INTEGER, INTENT(OUT) :: size
(  370)*        INTEGER, INTENT(OUT) :: ierror
(  371)*      END SUBROUTINE MPI_Sizeof_int8_r3
(  372)*
(  373)*      SUBROUTINE MPI_Sizeof_int8_r4(x, size, ierror)
(  374)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT8
(  375)*      INTEGER(INT8), DIMENSION(1,1,1,*)::x
(  376)*        INTEGER, INTENT(OUT) :: size
(  377)*        INTEGER, INTENT(OUT) :: ierror
(  378)*      END SUBROUTINE MPI_Sizeof_int8_r4
(  379)*
(  380)*      SUBROUTINE MPI_Sizeof_int8_r5(x, size, ierror)
(  381)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT8
(  382)*      INTEGER(INT8), DIMENSION(1,1,1,1,*)::x
(  383)*        INTEGER, INTENT(OUT) :: size
(  384)*        INTEGER, INTENT(OUT) :: ierror
(  385)*      END SUBROUTINE MPI_Sizeof_int8_r5
(  386)*
(  387)*      SUBROUTINE MPI_Sizeof_int8_r6(x, size, ierror)
(  388)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT8
(  389)*      INTEGER(INT8), DIMENSION(1,1,1,1,1,*)::x
(  390)*        INTEGER, INTENT(OUT) :: size
(  391)*        INTEGER, INTENT(OUT) :: ierror
(  392)*      END SUBROUTINE MPI_Sizeof_int8_r6
(  393)*
(  394)*      SUBROUTINE MPI_Sizeof_int8_r7(x, size, ierror)
(  395)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT8
(  396)*      INTEGER(INT8), DIMENSION(1,1,1,1,1,1,*)::x
(  397)*        INTEGER, INTENT(OUT) :: size
(  398)*        INTEGER, INTENT(OUT) :: ierror
(  399)*      END SUBROUTINE MPI_Sizeof_int8_r7
(  400)*
(  401)*      SUBROUTINE MPI_Sizeof_logical_scalar(x, size, ierror)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 66

(  402)*      LOGICAL::x
(  403)*        INTEGER, INTENT(OUT) :: size
(  404)*        INTEGER, INTENT(OUT) :: ierror
(  405)*      END SUBROUTINE MPI_Sizeof_logical_scalar
(  406)*
(  407)*      SUBROUTINE MPI_Sizeof_logical_r1(x, size, ierror)
(  408)*      LOGICAL, DIMENSION(*)::x
(  409)*        INTEGER, INTENT(OUT) :: size
(  410)*        INTEGER, INTENT(OUT) :: ierror
(  411)*      END SUBROUTINE MPI_Sizeof_logical_r1
(  412)*
(  413)*      SUBROUTINE MPI_Sizeof_logical_r2(x, size, ierror)
(  414)*      LOGICAL, DIMENSION(1,*)::x
(  415)*        INTEGER, INTENT(OUT) :: size
(  416)*        INTEGER, INTENT(OUT) :: ierror
(  417)*      END SUBROUTINE MPI_Sizeof_logical_r2
(  418)*
(  419)*      SUBROUTINE MPI_Sizeof_logical_r3(x, size, ierror)
(  420)*      LOGICAL, DIMENSION(1,1,*)::x
(  421)*        INTEGER, INTENT(OUT) :: size
(  422)*        INTEGER, INTENT(OUT) :: ierror
(  423)*      END SUBROUTINE MPI_Sizeof_logical_r3
(  424)*
(  425)*      SUBROUTINE MPI_Sizeof_logical_r4(x, size, ierror)
(  426)*      LOGICAL, DIMENSION(1,1,1,*)::x
(  427)*        INTEGER, INTENT(OUT) :: size
(  428)*        INTEGER, INTENT(OUT) :: ierror
(  429)*      END SUBROUTINE MPI_Sizeof_logical_r4
(  430)*
(  431)*      SUBROUTINE MPI_Sizeof_logical_r5(x, size, ierror)
(  432)*      LOGICAL, DIMENSION(1,1,1,1,*)::x
(  433)*        INTEGER, INTENT(OUT) :: size
(  434)*        INTEGER, INTENT(OUT) :: ierror
(  435)*      END SUBROUTINE MPI_Sizeof_logical_r5
(  436)*
(  437)*      SUBROUTINE MPI_Sizeof_logical_r6(x, size, ierror)
(  438)*      LOGICAL, DIMENSION(1,1,1,1,1,*)::x
(  439)*        INTEGER, INTENT(OUT) :: size
(  440)*        INTEGER, INTENT(OUT) :: ierror
(  441)*      END SUBROUTINE MPI_Sizeof_logical_r6
(  442)*
(  443)*      SUBROUTINE MPI_Sizeof_logical_r7(x, size, ierror)
(  444)*      LOGICAL, DIMENSION(1,1,1,1,1,1,*)::x
(  445)*        INTEGER, INTENT(OUT) :: size
(  446)*        INTEGER, INTENT(OUT) :: ierror
(  447)*      END SUBROUTINE MPI_Sizeof_logical_r7
(  448)*
(  449)*      SUBROUTINE MPI_Sizeof_real32_scalar(x, size, ierror)
(  450)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  451)*      REAL(REAL32)::x
(  452)*        INTEGER, INTENT(OUT) :: size
(  453)*        INTEGER, INTENT(OUT) :: ierror
(  454)*      END SUBROUTINE MPI_Sizeof_real32_scalar
(  455)*
(  456)*      SUBROUTINE MPI_Sizeof_real32_r1(x, size, ierror)
(  457)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  458)*      REAL(REAL32), DIMENSION(*)::x
(  459)*        INTEGER, INTENT(OUT) :: size






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 67

(  460)*        INTEGER, INTENT(OUT) :: ierror
(  461)*      END SUBROUTINE MPI_Sizeof_real32_r1
(  462)*
(  463)*      SUBROUTINE MPI_Sizeof_real32_r2(x, size, ierror)
(  464)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  465)*      REAL(REAL32), DIMENSION(1,*)::x
(  466)*        INTEGER, INTENT(OUT) :: size
(  467)*        INTEGER, INTENT(OUT) :: ierror
(  468)*      END SUBROUTINE MPI_Sizeof_real32_r2
(  469)*
(  470)*      SUBROUTINE MPI_Sizeof_real32_r3(x, size, ierror)
(  471)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  472)*      REAL(REAL32), DIMENSION(1,1,*)::x
(  473)*        INTEGER, INTENT(OUT) :: size
(  474)*        INTEGER, INTENT(OUT) :: ierror
(  475)*      END SUBROUTINE MPI_Sizeof_real32_r3
(  476)*
(  477)*      SUBROUTINE MPI_Sizeof_real32_r4(x, size, ierror)
(  478)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  479)*      REAL(REAL32), DIMENSION(1,1,1,*)::x
(  480)*        INTEGER, INTENT(OUT) :: size
(  481)*        INTEGER, INTENT(OUT) :: ierror
(  482)*      END SUBROUTINE MPI_Sizeof_real32_r4
(  483)*
(  484)*      SUBROUTINE MPI_Sizeof_real32_r5(x, size, ierror)
(  485)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  486)*      REAL(REAL32), DIMENSION(1,1,1,1,*)::x
(  487)*        INTEGER, INTENT(OUT) :: size
(  488)*        INTEGER, INTENT(OUT) :: ierror
(  489)*      END SUBROUTINE MPI_Sizeof_real32_r5
(  490)*
(  491)*      SUBROUTINE MPI_Sizeof_real32_r6(x, size, ierror)
(  492)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  493)*      REAL(REAL32), DIMENSION(1,1,1,1,1,*)::x
(  494)*        INTEGER, INTENT(OUT) :: size
(  495)*        INTEGER, INTENT(OUT) :: ierror
(  496)*      END SUBROUTINE MPI_Sizeof_real32_r6
(  497)*
(  498)*      SUBROUTINE MPI_Sizeof_real32_r7(x, size, ierror)
(  499)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  500)*      REAL(REAL32), DIMENSION(1,1,1,1,1,1,*)::x
(  501)*        INTEGER, INTENT(OUT) :: size
(  502)*        INTEGER, INTENT(OUT) :: ierror
(  503)*      END SUBROUTINE MPI_Sizeof_real32_r7
(  504)*
(  505)*      SUBROUTINE MPI_Sizeof_real64_scalar(x, size, ierror)
(  506)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  507)*      REAL(REAL64)::x
(  508)*        INTEGER, INTENT(OUT) :: size
(  509)*        INTEGER, INTENT(OUT) :: ierror
(  510)*      END SUBROUTINE MPI_Sizeof_real64_scalar
(  511)*
(  512)*      SUBROUTINE MPI_Sizeof_real64_r1(x, size, ierror)
(  513)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  514)*      REAL(REAL64), DIMENSION(*)::x
(  515)*        INTEGER, INTENT(OUT) :: size
(  516)*        INTEGER, INTENT(OUT) :: ierror
(  517)*      END SUBROUTINE MPI_Sizeof_real64_r1






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 68

(  518)*
(  519)*      SUBROUTINE MPI_Sizeof_real64_r2(x, size, ierror)
(  520)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  521)*      REAL(REAL64), DIMENSION(1,*)::x
(  522)*        INTEGER, INTENT(OUT) :: size
(  523)*        INTEGER, INTENT(OUT) :: ierror
(  524)*      END SUBROUTINE MPI_Sizeof_real64_r2
(  525)*
(  526)*      SUBROUTINE MPI_Sizeof_real64_r3(x, size, ierror)
(  527)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  528)*      REAL(REAL64), DIMENSION(1,1,*)::x
(  529)*        INTEGER, INTENT(OUT) :: size
(  530)*        INTEGER, INTENT(OUT) :: ierror
(  531)*      END SUBROUTINE MPI_Sizeof_real64_r3
(  532)*
(  533)*      SUBROUTINE MPI_Sizeof_real64_r4(x, size, ierror)
(  534)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  535)*      REAL(REAL64), DIMENSION(1,1,1,*)::x
(  536)*        INTEGER, INTENT(OUT) :: size
(  537)*        INTEGER, INTENT(OUT) :: ierror
(  538)*      END SUBROUTINE MPI_Sizeof_real64_r4
(  539)*
(  540)*      SUBROUTINE MPI_Sizeof_real64_r5(x, size, ierror)
(  541)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  542)*      REAL(REAL64), DIMENSION(1,1,1,1,*)::x
(  543)*        INTEGER, INTENT(OUT) :: size
(  544)*        INTEGER, INTENT(OUT) :: ierror
(  545)*      END SUBROUTINE MPI_Sizeof_real64_r5
(  546)*
(  547)*      SUBROUTINE MPI_Sizeof_real64_r6(x, size, ierror)
(  548)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  549)*      REAL(REAL64), DIMENSION(1,1,1,1,1,*)::x
(  550)*        INTEGER, INTENT(OUT) :: size
(  551)*        INTEGER, INTENT(OUT) :: ierror
(  552)*      END SUBROUTINE MPI_Sizeof_real64_r6
(  553)*
(  554)*      SUBROUTINE MPI_Sizeof_real64_r7(x, size, ierror)
(  555)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  556)*      REAL(REAL64), DIMENSION(1,1,1,1,1,1,*)::x
(  557)*        INTEGER, INTENT(OUT) :: size
(  558)*        INTEGER, INTENT(OUT) :: ierror
(  559)*      END SUBROUTINE MPI_Sizeof_real64_r7
(  560)*
(  561)*      END INTERFACE MPI_Sizeof
(  562)*
(  563)*      INTERFACE PMPI_Sizeof
(  564)*
(  565)*      SUBROUTINE PMPI_Sizeof_character_scalar(x, size, ierror)
(  566)*      CHARACTER::x
(  567)*        INTEGER, INTENT(OUT) :: size
(  568)*        INTEGER, INTENT(OUT) :: ierror
(  569)*      END SUBROUTINE PMPI_Sizeof_character_scalar
(  570)*
(  571)*      SUBROUTINE PMPI_Sizeof_character_r1(x, size, ierror)
(  572)*      CHARACTER, DIMENSION(*)::x
(  573)*        INTEGER, INTENT(OUT) :: size
(  574)*        INTEGER, INTENT(OUT) :: ierror
(  575)*      END SUBROUTINE PMPI_Sizeof_character_r1






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 69

(  576)*
(  577)*      SUBROUTINE PMPI_Sizeof_character_r2(x, size, ierror)
(  578)*      CHARACTER, DIMENSION(1,*)::x
(  579)*        INTEGER, INTENT(OUT) :: size
(  580)*        INTEGER, INTENT(OUT) :: ierror
(  581)*      END SUBROUTINE PMPI_Sizeof_character_r2
(  582)*
(  583)*      SUBROUTINE PMPI_Sizeof_character_r3(x, size, ierror)
(  584)*      CHARACTER, DIMENSION(1,1,*)::x
(  585)*        INTEGER, INTENT(OUT) :: size
(  586)*        INTEGER, INTENT(OUT) :: ierror
(  587)*      END SUBROUTINE PMPI_Sizeof_character_r3
(  588)*
(  589)*      SUBROUTINE PMPI_Sizeof_character_r4(x, size, ierror)
(  590)*      CHARACTER, DIMENSION(1,1,1,*)::x
(  591)*        INTEGER, INTENT(OUT) :: size
(  592)*        INTEGER, INTENT(OUT) :: ierror
(  593)*      END SUBROUTINE PMPI_Sizeof_character_r4
(  594)*
(  595)*      SUBROUTINE PMPI_Sizeof_character_r5(x, size, ierror)
(  596)*      CHARACTER, DIMENSION(1,1,1,1,*)::x
(  597)*        INTEGER, INTENT(OUT) :: size
(  598)*        INTEGER, INTENT(OUT) :: ierror
(  599)*      END SUBROUTINE PMPI_Sizeof_character_r5
(  600)*
(  601)*      SUBROUTINE PMPI_Sizeof_character_r6(x, size, ierror)
(  602)*      CHARACTER, DIMENSION(1,1,1,1,1,*)::x
(  603)*        INTEGER, INTENT(OUT) :: size
(  604)*        INTEGER, INTENT(OUT) :: ierror
(  605)*      END SUBROUTINE PMPI_Sizeof_character_r6
(  606)*
(  607)*      SUBROUTINE PMPI_Sizeof_character_r7(x, size, ierror)
(  608)*      CHARACTER, DIMENSION(1,1,1,1,1,1,*)::x
(  609)*        INTEGER, INTENT(OUT) :: size
(  610)*        INTEGER, INTENT(OUT) :: ierror
(  611)*      END SUBROUTINE PMPI_Sizeof_character_r7
(  612)*
(  613)*      SUBROUTINE PMPI_Sizeof_complex32_scalar(x, size, ierror)
(  614)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  615)*      COMPLEX(REAL32)::x
(  616)*        INTEGER, INTENT(OUT) :: size
(  617)*        INTEGER, INTENT(OUT) :: ierror
(  618)*      END SUBROUTINE PMPI_Sizeof_complex32_scalar
(  619)*
(  620)*      SUBROUTINE PMPI_Sizeof_complex32_r1(x, size, ierror)
(  621)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  622)*      COMPLEX(REAL32), DIMENSION(*)::x
(  623)*        INTEGER, INTENT(OUT) :: size
(  624)*        INTEGER, INTENT(OUT) :: ierror
(  625)*      END SUBROUTINE PMPI_Sizeof_complex32_r1
(  626)*
(  627)*      SUBROUTINE PMPI_Sizeof_complex32_r2(x, size, ierror)
(  628)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  629)*      COMPLEX(REAL32), DIMENSION(1,*)::x
(  630)*        INTEGER, INTENT(OUT) :: size
(  631)*        INTEGER, INTENT(OUT) :: ierror
(  632)*      END SUBROUTINE PMPI_Sizeof_complex32_r2
(  633)*






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 70

(  634)*      SUBROUTINE PMPI_Sizeof_complex32_r3(x, size, ierror)
(  635)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  636)*      COMPLEX(REAL32), DIMENSION(1,1,*)::x
(  637)*        INTEGER, INTENT(OUT) :: size
(  638)*        INTEGER, INTENT(OUT) :: ierror
(  639)*      END SUBROUTINE PMPI_Sizeof_complex32_r3
(  640)*
(  641)*      SUBROUTINE PMPI_Sizeof_complex32_r4(x, size, ierror)
(  642)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  643)*      COMPLEX(REAL32), DIMENSION(1,1,1,*)::x
(  644)*        INTEGER, INTENT(OUT) :: size
(  645)*        INTEGER, INTENT(OUT) :: ierror
(  646)*      END SUBROUTINE PMPI_Sizeof_complex32_r4
(  647)*
(  648)*      SUBROUTINE PMPI_Sizeof_complex32_r5(x, size, ierror)
(  649)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  650)*      COMPLEX(REAL32), DIMENSION(1,1,1,1,*)::x
(  651)*        INTEGER, INTENT(OUT) :: size
(  652)*        INTEGER, INTENT(OUT) :: ierror
(  653)*      END SUBROUTINE PMPI_Sizeof_complex32_r5
(  654)*
(  655)*      SUBROUTINE PMPI_Sizeof_complex32_r6(x, size, ierror)
(  656)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  657)*      COMPLEX(REAL32), DIMENSION(1,1,1,1,1,*)::x
(  658)*        INTEGER, INTENT(OUT) :: size
(  659)*        INTEGER, INTENT(OUT) :: ierror
(  660)*      END SUBROUTINE PMPI_Sizeof_complex32_r6
(  661)*
(  662)*      SUBROUTINE PMPI_Sizeof_complex32_r7(x, size, ierror)
(  663)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  664)*      COMPLEX(REAL32), DIMENSION(1,1,1,1,1,1,*)::x
(  665)*        INTEGER, INTENT(OUT) :: size
(  666)*        INTEGER, INTENT(OUT) :: ierror
(  667)*      END SUBROUTINE PMPI_Sizeof_complex32_r7
(  668)*
(  669)*      SUBROUTINE PMPI_Sizeof_complex64_scalar(x, size, ierror)
(  670)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  671)*      COMPLEX(REAL64)::x
(  672)*        INTEGER, INTENT(OUT) :: size
(  673)*        INTEGER, INTENT(OUT) :: ierror
(  674)*      END SUBROUTINE PMPI_Sizeof_complex64_scalar
(  675)*
(  676)*      SUBROUTINE PMPI_Sizeof_complex64_r1(x, size, ierror)
(  677)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  678)*      COMPLEX(REAL64), DIMENSION(*)::x
(  679)*        INTEGER, INTENT(OUT) :: size
(  680)*        INTEGER, INTENT(OUT) :: ierror
(  681)*      END SUBROUTINE PMPI_Sizeof_complex64_r1
(  682)*
(  683)*      SUBROUTINE PMPI_Sizeof_complex64_r2(x, size, ierror)
(  684)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  685)*      COMPLEX(REAL64), DIMENSION(1,*)::x
(  686)*        INTEGER, INTENT(OUT) :: size
(  687)*        INTEGER, INTENT(OUT) :: ierror
(  688)*      END SUBROUTINE PMPI_Sizeof_complex64_r2
(  689)*
(  690)*      SUBROUTINE PMPI_Sizeof_complex64_r3(x, size, ierror)
(  691)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 71

(  692)*      COMPLEX(REAL64), DIMENSION(1,1,*)::x
(  693)*        INTEGER, INTENT(OUT) :: size
(  694)*        INTEGER, INTENT(OUT) :: ierror
(  695)*      END SUBROUTINE PMPI_Sizeof_complex64_r3
(  696)*
(  697)*      SUBROUTINE PMPI_Sizeof_complex64_r4(x, size, ierror)
(  698)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  699)*      COMPLEX(REAL64), DIMENSION(1,1,1,*)::x
(  700)*        INTEGER, INTENT(OUT) :: size
(  701)*        INTEGER, INTENT(OUT) :: ierror
(  702)*      END SUBROUTINE PMPI_Sizeof_complex64_r4
(  703)*
(  704)*      SUBROUTINE PMPI_Sizeof_complex64_r5(x, size, ierror)
(  705)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  706)*      COMPLEX(REAL64), DIMENSION(1,1,1,1,*)::x
(  707)*        INTEGER, INTENT(OUT) :: size
(  708)*        INTEGER, INTENT(OUT) :: ierror
(  709)*      END SUBROUTINE PMPI_Sizeof_complex64_r5
(  710)*
(  711)*      SUBROUTINE PMPI_Sizeof_complex64_r6(x, size, ierror)
(  712)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  713)*      COMPLEX(REAL64), DIMENSION(1,1,1,1,1,*)::x
(  714)*        INTEGER, INTENT(OUT) :: size
(  715)*        INTEGER, INTENT(OUT) :: ierror
(  716)*      END SUBROUTINE PMPI_Sizeof_complex64_r6
(  717)*
(  718)*      SUBROUTINE PMPI_Sizeof_complex64_r7(x, size, ierror)
(  719)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
(  720)*      COMPLEX(REAL64), DIMENSION(1,1,1,1,1,1,*)::x
(  721)*        INTEGER, INTENT(OUT) :: size
(  722)*        INTEGER, INTENT(OUT) :: ierror
(  723)*      END SUBROUTINE PMPI_Sizeof_complex64_r7
(  724)*
(  725)*      SUBROUTINE PMPI_Sizeof_int16_scalar(x, size, ierror)
(  726)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT16
(  727)*      INTEGER(INT16)::x
(  728)*        INTEGER, INTENT(OUT) :: size
(  729)*        INTEGER, INTENT(OUT) :: ierror
(  730)*      END SUBROUTINE PMPI_Sizeof_int16_scalar
(  731)*
(  732)*      SUBROUTINE PMPI_Sizeof_int16_r1(x, size, ierror)
(  733)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT16
(  734)*      INTEGER(INT16), DIMENSION(*)::x
(  735)*        INTEGER, INTENT(OUT) :: size
(  736)*        INTEGER, INTENT(OUT) :: ierror
(  737)*      END SUBROUTINE PMPI_Sizeof_int16_r1
(  738)*
(  739)*      SUBROUTINE PMPI_Sizeof_int16_r2(x, size, ierror)
(  740)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT16
(  741)*      INTEGER(INT16), DIMENSION(1,*)::x
(  742)*        INTEGER, INTENT(OUT) :: size
(  743)*        INTEGER, INTENT(OUT) :: ierror
(  744)*      END SUBROUTINE PMPI_Sizeof_int16_r2
(  745)*
(  746)*      SUBROUTINE PMPI_Sizeof_int16_r3(x, size, ierror)
(  747)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT16
(  748)*      INTEGER(INT16), DIMENSION(1,1,*)::x
(  749)*        INTEGER, INTENT(OUT) :: size






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 72

(  750)*        INTEGER, INTENT(OUT) :: ierror
(  751)*      END SUBROUTINE PMPI_Sizeof_int16_r3
(  752)*
(  753)*      SUBROUTINE PMPI_Sizeof_int16_r4(x, size, ierror)
(  754)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT16
(  755)*      INTEGER(INT16), DIMENSION(1,1,1,*)::x
(  756)*        INTEGER, INTENT(OUT) :: size
(  757)*        INTEGER, INTENT(OUT) :: ierror
(  758)*      END SUBROUTINE PMPI_Sizeof_int16_r4
(  759)*
(  760)*      SUBROUTINE PMPI_Sizeof_int16_r5(x, size, ierror)
(  761)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT16
(  762)*      INTEGER(INT16), DIMENSION(1,1,1,1,*)::x
(  763)*        INTEGER, INTENT(OUT) :: size
(  764)*        INTEGER, INTENT(OUT) :: ierror
(  765)*      END SUBROUTINE PMPI_Sizeof_int16_r5
(  766)*
(  767)*      SUBROUTINE PMPI_Sizeof_int16_r6(x, size, ierror)
(  768)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT16
(  769)*      INTEGER(INT16), DIMENSION(1,1,1,1,1,*)::x
(  770)*        INTEGER, INTENT(OUT) :: size
(  771)*        INTEGER, INTENT(OUT) :: ierror
(  772)*      END SUBROUTINE PMPI_Sizeof_int16_r6
(  773)*
(  774)*      SUBROUTINE PMPI_Sizeof_int16_r7(x, size, ierror)
(  775)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT16
(  776)*      INTEGER(INT16), DIMENSION(1,1,1,1,1,1,*)::x
(  777)*        INTEGER, INTENT(OUT) :: size
(  778)*        INTEGER, INTENT(OUT) :: ierror
(  779)*      END SUBROUTINE PMPI_Sizeof_int16_r7
(  780)*
(  781)*      SUBROUTINE PMPI_Sizeof_int32_scalar(x, size, ierror)
(  782)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT32
(  783)*      INTEGER(INT32)::x
(  784)*        INTEGER, INTENT(OUT) :: size
(  785)*        INTEGER, INTENT(OUT) :: ierror
(  786)*      END SUBROUTINE PMPI_Sizeof_int32_scalar
(  787)*
(  788)*      SUBROUTINE PMPI_Sizeof_int32_r1(x, size, ierror)
(  789)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT32
(  790)*      INTEGER(INT32), DIMENSION(*)::x
(  791)*        INTEGER, INTENT(OUT) :: size
(  792)*        INTEGER, INTENT(OUT) :: ierror
(  793)*      END SUBROUTINE PMPI_Sizeof_int32_r1
(  794)*
(  795)*      SUBROUTINE PMPI_Sizeof_int32_r2(x, size, ierror)
(  796)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT32
(  797)*      INTEGER(INT32), DIMENSION(1,*)::x
(  798)*        INTEGER, INTENT(OUT) :: size
(  799)*        INTEGER, INTENT(OUT) :: ierror
(  800)*      END SUBROUTINE PMPI_Sizeof_int32_r2
(  801)*
(  802)*      SUBROUTINE PMPI_Sizeof_int32_r3(x, size, ierror)
(  803)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT32
(  804)*      INTEGER(INT32), DIMENSION(1,1,*)::x
(  805)*        INTEGER, INTENT(OUT) :: size
(  806)*        INTEGER, INTENT(OUT) :: ierror
(  807)*      END SUBROUTINE PMPI_Sizeof_int32_r3






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 73

(  808)*
(  809)*      SUBROUTINE PMPI_Sizeof_int32_r4(x, size, ierror)
(  810)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT32
(  811)*      INTEGER(INT32), DIMENSION(1,1,1,*)::x
(  812)*        INTEGER, INTENT(OUT) :: size
(  813)*        INTEGER, INTENT(OUT) :: ierror
(  814)*      END SUBROUTINE PMPI_Sizeof_int32_r4
(  815)*
(  816)*      SUBROUTINE PMPI_Sizeof_int32_r5(x, size, ierror)
(  817)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT32
(  818)*      INTEGER(INT32), DIMENSION(1,1,1,1,*)::x
(  819)*        INTEGER, INTENT(OUT) :: size
(  820)*        INTEGER, INTENT(OUT) :: ierror
(  821)*      END SUBROUTINE PMPI_Sizeof_int32_r5
(  822)*
(  823)*      SUBROUTINE PMPI_Sizeof_int32_r6(x, size, ierror)
(  824)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT32
(  825)*      INTEGER(INT32), DIMENSION(1,1,1,1,1,*)::x
(  826)*        INTEGER, INTENT(OUT) :: size
(  827)*        INTEGER, INTENT(OUT) :: ierror
(  828)*      END SUBROUTINE PMPI_Sizeof_int32_r6
(  829)*
(  830)*      SUBROUTINE PMPI_Sizeof_int32_r7(x, size, ierror)
(  831)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT32
(  832)*      INTEGER(INT32), DIMENSION(1,1,1,1,1,1,*)::x
(  833)*        INTEGER, INTENT(OUT) :: size
(  834)*        INTEGER, INTENT(OUT) :: ierror
(  835)*      END SUBROUTINE PMPI_Sizeof_int32_r7
(  836)*
(  837)*      SUBROUTINE PMPI_Sizeof_int64_scalar(x, size, ierror)
(  838)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT64
(  839)*      INTEGER(INT64)::x
(  840)*        INTEGER, INTENT(OUT) :: size
(  841)*        INTEGER, INTENT(OUT) :: ierror
(  842)*      END SUBROUTINE PMPI_Sizeof_int64_scalar
(  843)*
(  844)*      SUBROUTINE PMPI_Sizeof_int64_r1(x, size, ierror)
(  845)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT64
(  846)*      INTEGER(INT64), DIMENSION(*)::x
(  847)*        INTEGER, INTENT(OUT) :: size
(  848)*        INTEGER, INTENT(OUT) :: ierror
(  849)*      END SUBROUTINE PMPI_Sizeof_int64_r1
(  850)*
(  851)*      SUBROUTINE PMPI_Sizeof_int64_r2(x, size, ierror)
(  852)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT64
(  853)*      INTEGER(INT64), DIMENSION(1,*)::x
(  854)*        INTEGER, INTENT(OUT) :: size
(  855)*        INTEGER, INTENT(OUT) :: ierror
(  856)*      END SUBROUTINE PMPI_Sizeof_int64_r2
(  857)*
(  858)*      SUBROUTINE PMPI_Sizeof_int64_r3(x, size, ierror)
(  859)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT64
(  860)*      INTEGER(INT64), DIMENSION(1,1,*)::x
(  861)*        INTEGER, INTENT(OUT) :: size
(  862)*        INTEGER, INTENT(OUT) :: ierror
(  863)*      END SUBROUTINE PMPI_Sizeof_int64_r3
(  864)*
(  865)*      SUBROUTINE PMPI_Sizeof_int64_r4(x, size, ierror)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 74

(  866)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT64
(  867)*      INTEGER(INT64), DIMENSION(1,1,1,*)::x
(  868)*        INTEGER, INTENT(OUT) :: size
(  869)*        INTEGER, INTENT(OUT) :: ierror
(  870)*      END SUBROUTINE PMPI_Sizeof_int64_r4
(  871)*
(  872)*      SUBROUTINE PMPI_Sizeof_int64_r5(x, size, ierror)
(  873)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT64
(  874)*      INTEGER(INT64), DIMENSION(1,1,1,1,*)::x
(  875)*        INTEGER, INTENT(OUT) :: size
(  876)*        INTEGER, INTENT(OUT) :: ierror
(  877)*      END SUBROUTINE PMPI_Sizeof_int64_r5
(  878)*
(  879)*      SUBROUTINE PMPI_Sizeof_int64_r6(x, size, ierror)
(  880)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT64
(  881)*      INTEGER(INT64), DIMENSION(1,1,1,1,1,*)::x
(  882)*        INTEGER, INTENT(OUT) :: size
(  883)*        INTEGER, INTENT(OUT) :: ierror
(  884)*      END SUBROUTINE PMPI_Sizeof_int64_r6
(  885)*
(  886)*      SUBROUTINE PMPI_Sizeof_int64_r7(x, size, ierror)
(  887)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT64
(  888)*      INTEGER(INT64), DIMENSION(1,1,1,1,1,1,*)::x
(  889)*        INTEGER, INTENT(OUT) :: size
(  890)*        INTEGER, INTENT(OUT) :: ierror
(  891)*      END SUBROUTINE PMPI_Sizeof_int64_r7
(  892)*
(  893)*      SUBROUTINE PMPI_Sizeof_int8_scalar(x, size, ierror)
(  894)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT8
(  895)*      INTEGER(INT8)::x
(  896)*        INTEGER, INTENT(OUT) :: size
(  897)*        INTEGER, INTENT(OUT) :: ierror
(  898)*      END SUBROUTINE PMPI_Sizeof_int8_scalar
(  899)*
(  900)*      SUBROUTINE PMPI_Sizeof_int8_r1(x, size, ierror)
(  901)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT8
(  902)*      INTEGER(INT8), DIMENSION(*)::x
(  903)*        INTEGER, INTENT(OUT) :: size
(  904)*        INTEGER, INTENT(OUT) :: ierror
(  905)*      END SUBROUTINE PMPI_Sizeof_int8_r1
(  906)*
(  907)*      SUBROUTINE PMPI_Sizeof_int8_r2(x, size, ierror)
(  908)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT8
(  909)*      INTEGER(INT8), DIMENSION(1,*)::x
(  910)*        INTEGER, INTENT(OUT) :: size
(  911)*        INTEGER, INTENT(OUT) :: ierror
(  912)*      END SUBROUTINE PMPI_Sizeof_int8_r2
(  913)*
(  914)*      SUBROUTINE PMPI_Sizeof_int8_r3(x, size, ierror)
(  915)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT8
(  916)*      INTEGER(INT8), DIMENSION(1,1,*)::x
(  917)*        INTEGER, INTENT(OUT) :: size
(  918)*        INTEGER, INTENT(OUT) :: ierror
(  919)*      END SUBROUTINE PMPI_Sizeof_int8_r3
(  920)*
(  921)*      SUBROUTINE PMPI_Sizeof_int8_r4(x, size, ierror)
(  922)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT8
(  923)*      INTEGER(INT8), DIMENSION(1,1,1,*)::x






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 75

(  924)*        INTEGER, INTENT(OUT) :: size
(  925)*        INTEGER, INTENT(OUT) :: ierror
(  926)*      END SUBROUTINE PMPI_Sizeof_int8_r4
(  927)*
(  928)*      SUBROUTINE PMPI_Sizeof_int8_r5(x, size, ierror)
(  929)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT8
(  930)*      INTEGER(INT8), DIMENSION(1,1,1,1,*)::x
(  931)*        INTEGER, INTENT(OUT) :: size
(  932)*        INTEGER, INTENT(OUT) :: ierror
(  933)*      END SUBROUTINE PMPI_Sizeof_int8_r5
(  934)*
(  935)*      SUBROUTINE PMPI_Sizeof_int8_r6(x, size, ierror)
(  936)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT8
(  937)*      INTEGER(INT8), DIMENSION(1,1,1,1,1,*)::x
(  938)*        INTEGER, INTENT(OUT) :: size
(  939)*        INTEGER, INTENT(OUT) :: ierror
(  940)*      END SUBROUTINE PMPI_Sizeof_int8_r6
(  941)*
(  942)*      SUBROUTINE PMPI_Sizeof_int8_r7(x, size, ierror)
(  943)*        USE, INTRINSIC :: iso_fortran_env, ONLY: INT8
(  944)*      INTEGER(INT8), DIMENSION(1,1,1,1,1,1,*)::x
(  945)*        INTEGER, INTENT(OUT) :: size
(  946)*        INTEGER, INTENT(OUT) :: ierror
(  947)*      END SUBROUTINE PMPI_Sizeof_int8_r7
(  948)*
(  949)*      SUBROUTINE PMPI_Sizeof_logical_scalar(x, size, ierror)
(  950)*      LOGICAL::x
(  951)*        INTEGER, INTENT(OUT) :: size
(  952)*        INTEGER, INTENT(OUT) :: ierror
(  953)*      END SUBROUTINE PMPI_Sizeof_logical_scalar
(  954)*
(  955)*      SUBROUTINE PMPI_Sizeof_logical_r1(x, size, ierror)
(  956)*      LOGICAL, DIMENSION(*)::x
(  957)*        INTEGER, INTENT(OUT) :: size
(  958)*        INTEGER, INTENT(OUT) :: ierror
(  959)*      END SUBROUTINE PMPI_Sizeof_logical_r1
(  960)*
(  961)*      SUBROUTINE PMPI_Sizeof_logical_r2(x, size, ierror)
(  962)*      LOGICAL, DIMENSION(1,*)::x
(  963)*        INTEGER, INTENT(OUT) :: size
(  964)*        INTEGER, INTENT(OUT) :: ierror
(  965)*      END SUBROUTINE PMPI_Sizeof_logical_r2
(  966)*
(  967)*      SUBROUTINE PMPI_Sizeof_logical_r3(x, size, ierror)
(  968)*      LOGICAL, DIMENSION(1,1,*)::x
(  969)*        INTEGER, INTENT(OUT) :: size
(  970)*        INTEGER, INTENT(OUT) :: ierror
(  971)*      END SUBROUTINE PMPI_Sizeof_logical_r3
(  972)*
(  973)*      SUBROUTINE PMPI_Sizeof_logical_r4(x, size, ierror)
(  974)*      LOGICAL, DIMENSION(1,1,1,*)::x
(  975)*        INTEGER, INTENT(OUT) :: size
(  976)*        INTEGER, INTENT(OUT) :: ierror
(  977)*      END SUBROUTINE PMPI_Sizeof_logical_r4
(  978)*
(  979)*      SUBROUTINE PMPI_Sizeof_logical_r5(x, size, ierror)
(  980)*      LOGICAL, DIMENSION(1,1,1,1,*)::x
(  981)*        INTEGER, INTENT(OUT) :: size






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 76

(  982)*        INTEGER, INTENT(OUT) :: ierror
(  983)*      END SUBROUTINE PMPI_Sizeof_logical_r5
(  984)*
(  985)*      SUBROUTINE PMPI_Sizeof_logical_r6(x, size, ierror)
(  986)*      LOGICAL, DIMENSION(1,1,1,1,1,*)::x
(  987)*        INTEGER, INTENT(OUT) :: size
(  988)*        INTEGER, INTENT(OUT) :: ierror
(  989)*      END SUBROUTINE PMPI_Sizeof_logical_r6
(  990)*
(  991)*      SUBROUTINE PMPI_Sizeof_logical_r7(x, size, ierror)
(  992)*      LOGICAL, DIMENSION(1,1,1,1,1,1,*)::x
(  993)*        INTEGER, INTENT(OUT) :: size
(  994)*        INTEGER, INTENT(OUT) :: ierror
(  995)*      END SUBROUTINE PMPI_Sizeof_logical_r7
(  996)*
(  997)*      SUBROUTINE PMPI_Sizeof_real32_scalar(x, size, ierror)
(  998)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
(  999)*      REAL(REAL32)::x
( 1000)*        INTEGER, INTENT(OUT) :: size
( 1001)*        INTEGER, INTENT(OUT) :: ierror
( 1002)*      END SUBROUTINE PMPI_Sizeof_real32_scalar
( 1003)*
( 1004)*      SUBROUTINE PMPI_Sizeof_real32_r1(x, size, ierror)
( 1005)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
( 1006)*      REAL(REAL32), DIMENSION(*)::x
( 1007)*        INTEGER, INTENT(OUT) :: size
( 1008)*        INTEGER, INTENT(OUT) :: ierror
( 1009)*      END SUBROUTINE PMPI_Sizeof_real32_r1
( 1010)*
( 1011)*      SUBROUTINE PMPI_Sizeof_real32_r2(x, size, ierror)
( 1012)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
( 1013)*      REAL(REAL32), DIMENSION(1,*)::x
( 1014)*        INTEGER, INTENT(OUT) :: size
( 1015)*        INTEGER, INTENT(OUT) :: ierror
( 1016)*      END SUBROUTINE PMPI_Sizeof_real32_r2
( 1017)*
( 1018)*      SUBROUTINE PMPI_Sizeof_real32_r3(x, size, ierror)
( 1019)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
( 1020)*      REAL(REAL32), DIMENSION(1,1,*)::x
( 1021)*        INTEGER, INTENT(OUT) :: size
( 1022)*        INTEGER, INTENT(OUT) :: ierror
( 1023)*      END SUBROUTINE PMPI_Sizeof_real32_r3
( 1024)*
( 1025)*      SUBROUTINE PMPI_Sizeof_real32_r4(x, size, ierror)
( 1026)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
( 1027)*      REAL(REAL32), DIMENSION(1,1,1,*)::x
( 1028)*        INTEGER, INTENT(OUT) :: size
( 1029)*        INTEGER, INTENT(OUT) :: ierror
( 1030)*      END SUBROUTINE PMPI_Sizeof_real32_r4
( 1031)*
( 1032)*      SUBROUTINE PMPI_Sizeof_real32_r5(x, size, ierror)
( 1033)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
( 1034)*      REAL(REAL32), DIMENSION(1,1,1,1,*)::x
( 1035)*        INTEGER, INTENT(OUT) :: size
( 1036)*        INTEGER, INTENT(OUT) :: ierror
( 1037)*      END SUBROUTINE PMPI_Sizeof_real32_r5
( 1038)*
( 1039)*      SUBROUTINE PMPI_Sizeof_real32_r6(x, size, ierror)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 77

( 1040)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
( 1041)*      REAL(REAL32), DIMENSION(1,1,1,1,1,*)::x
( 1042)*        INTEGER, INTENT(OUT) :: size
( 1043)*        INTEGER, INTENT(OUT) :: ierror
( 1044)*      END SUBROUTINE PMPI_Sizeof_real32_r6
( 1045)*
( 1046)*      SUBROUTINE PMPI_Sizeof_real32_r7(x, size, ierror)
( 1047)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL32
( 1048)*      REAL(REAL32), DIMENSION(1,1,1,1,1,1,*)::x
( 1049)*        INTEGER, INTENT(OUT) :: size
( 1050)*        INTEGER, INTENT(OUT) :: ierror
( 1051)*      END SUBROUTINE PMPI_Sizeof_real32_r7
( 1052)*
( 1053)*      SUBROUTINE PMPI_Sizeof_real64_scalar(x, size, ierror)
( 1054)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
( 1055)*      REAL(REAL64)::x
( 1056)*        INTEGER, INTENT(OUT) :: size
( 1057)*        INTEGER, INTENT(OUT) :: ierror
( 1058)*      END SUBROUTINE PMPI_Sizeof_real64_scalar
( 1059)*
( 1060)*      SUBROUTINE PMPI_Sizeof_real64_r1(x, size, ierror)
( 1061)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
( 1062)*      REAL(REAL64), DIMENSION(*)::x
( 1063)*        INTEGER, INTENT(OUT) :: size
( 1064)*        INTEGER, INTENT(OUT) :: ierror
( 1065)*      END SUBROUTINE PMPI_Sizeof_real64_r1
( 1066)*
( 1067)*      SUBROUTINE PMPI_Sizeof_real64_r2(x, size, ierror)
( 1068)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
( 1069)*      REAL(REAL64), DIMENSION(1,*)::x
( 1070)*        INTEGER, INTENT(OUT) :: size
( 1071)*        INTEGER, INTENT(OUT) :: ierror
( 1072)*      END SUBROUTINE PMPI_Sizeof_real64_r2
( 1073)*
( 1074)*      SUBROUTINE PMPI_Sizeof_real64_r3(x, size, ierror)
( 1075)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
( 1076)*      REAL(REAL64), DIMENSION(1,1,*)::x
( 1077)*        INTEGER, INTENT(OUT) :: size
( 1078)*        INTEGER, INTENT(OUT) :: ierror
( 1079)*      END SUBROUTINE PMPI_Sizeof_real64_r3
( 1080)*
( 1081)*      SUBROUTINE PMPI_Sizeof_real64_r4(x, size, ierror)
( 1082)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
( 1083)*      REAL(REAL64), DIMENSION(1,1,1,*)::x
( 1084)*        INTEGER, INTENT(OUT) :: size
( 1085)*        INTEGER, INTENT(OUT) :: ierror
( 1086)*      END SUBROUTINE PMPI_Sizeof_real64_r4
( 1087)*
( 1088)*      SUBROUTINE PMPI_Sizeof_real64_r5(x, size, ierror)
( 1089)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
( 1090)*      REAL(REAL64), DIMENSION(1,1,1,1,*)::x
( 1091)*        INTEGER, INTENT(OUT) :: size
( 1092)*        INTEGER, INTENT(OUT) :: ierror
( 1093)*      END SUBROUTINE PMPI_Sizeof_real64_r5
( 1094)*
( 1095)*      SUBROUTINE PMPI_Sizeof_real64_r6(x, size, ierror)
( 1096)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
( 1097)*      REAL(REAL64), DIMENSION(1,1,1,1,1,*)::x






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 78

( 1098)*        INTEGER, INTENT(OUT) :: size
( 1099)*        INTEGER, INTENT(OUT) :: ierror
( 1100)*      END SUBROUTINE PMPI_Sizeof_real64_r6
( 1101)*
( 1102)*      SUBROUTINE PMPI_Sizeof_real64_r7(x, size, ierror)
( 1103)*        USE, INTRINSIC :: iso_fortran_env, ONLY: REAL64
( 1104)*      REAL(REAL64), DIMENSION(1,1,1,1,1,1,*)::x
( 1105)*        INTEGER, INTENT(OUT) :: size
( 1106)*        INTEGER, INTENT(OUT) :: ierror
( 1107)*      END SUBROUTINE PMPI_Sizeof_real64_r7
( 1108)*
( 1109)*      END INTERFACE PMPI_Sizeof
( 1110)*
(    1) INTERFACE
(    2) # 3 ".D[12]/abor1.intfb.h"
(    3) SUBROUTINE ABOR1(CDTEXT)
(    4) CHARACTER(LEN=*), INTENT(IN) :: CDTEXT
(    5) END SUBROUTINE ABOR1
(    6) # 7 ".D[12]/abor1.intfb.h"
(    7) SUBROUTINE ABOR1FL(CDFILE, KLINENUM, CDTEXT)
(    8) USE PARKIND1  ,ONLY : JPIM
(    9) CHARACTER(LEN=*), INTENT(IN) :: CDFILE,CDTEXT
(   10) INTEGER(KIND=JPIM), INTENT(IN) :: KLINENUM
(   11) END SUBROUTINE ABOR1FL
(   12) # 13 ".D[12]/abor1.intfb.h"
(   13) SUBROUTINE ABOR1_EXCEPTION_HANDLER()
(   14) END SUBROUTINE ABOR1_EXCEPTION_HANDLER
(   15) # 16 ".D[12]/abor1.intfb.h"
(   16) END INTERFACE
(   17) # 70 "aatestprog.F90"
(   70) # 71 "aatestprog.F90"
(   71) NAMELIST / NAMAATESTPROG / & 
(   72)   & NFLDUA, NFLDSU, NMSMAX, NSMAX, NDGLG, NFLEVG, LDEBUG, NDLON, NPRINTLEV, NTIME, LELAM
(   73) # 74 "aatestprog.F90"
(   74) NAMELIST / NAMTRANS / & 
(   75)   & LUSEFLT, LUSERPNM, LKEEPRPNM
(   76) # 77 "aatestprog.F90"
(   77) NAMELIST / NAMPAR0 / & 
(   78)   & NPRGPNS, NPRGPEW, NPRTRW, NPRTRV
(   79) # 80 "aatestprog.F90"
(   80) NAMELIST / NAMPAR1 / & 
(   81)   & LEQ_REGIONS, LSPLIT
(   82) # 83 "aatestprog.F90"
(   83) NAMELIST / NAMRGRI / & 
(   84)   & NRGRI
(   85) # 86 "aatestprog.F90"
(   86) CHARACTER (LEN=64) :: CLNAMELIST
(   87) CHARACTER (LEN=64) :: CLFIELD
(   88) LOGICAL :: LLMPOFF, LLNOWRITE, LLNODIRTRANS, LLNOINVTRANS, LLTESTHARMONICS, LLALLOPERM
(   89) # 90 "aatestprog.F90"
(   90) REAL (KIND=JPRB) :: ZHOOK_HANDLE
(   91) # 92 "aatestprog.F90"
(   92) !CALL GPU_BIND_JZ
(   93) # 94 "aatestprog.F90"
(   94) CALL INITOPTIONS ()
(   95) CLNAMELIST = 'fort.4'
(   96) CALL GETOPTION ("--namelist", CLNAMELIST)
(   97) CALL GETOPTION ("--lmpoff", LLMPOFF)






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 79

(   98) NTIME     = 10
(   99) CALL GETOPTION ("--time", NTIME)
(  100) CLFIELD = ''
(  101) CALL GETOPTION ("--field-file", CLFIELD)
(  102) CALL GETOPTION ("--no-write", LLNOWRITE)
(  103) CALL GETOPTION ("--no-dir-trans", LLNODIRTRANS)
(  104) CALL GETOPTION ("--no-inv-trans", LLNOINVTRANS)
(  105) CALL GETOPTION ("--test-harmonics", LLTESTHARMONICS)
(  106) CALL GETOPTION ("--alloperm", LLALLOPERM)
(  107) CALL GETOPTION ("--check", LLCHECK)
(  108) CALL CHECKOPTIONS ()
(  109) # 110 "aatestprog.F90"
(  110) LLHOOK = LHOOK
(  111) LHOOK = .FALSE.
(  112) # 113 "aatestprog.F90"
(  113) OPEN (4, FILE=TRIM (CLNAMELIST), FORM='FORMATTED')
(  114) # 115 "aatestprog.F90"
(  115) LELAM     = .FALSE.
(  116) NFLDUA    = 1
(  117) NFLDSU    = 0
(  118) NPRINTLEV = 0
(  119) NSMAX     = 0
(  120) NMSMAX    = 0
(  121) NDGLG     = 0
(  122) NFLEVG    = 19
(  123) LDEBUG    = .FALSE.
(  124) # 125 "aatestprog.F90"
(  125) CALL POSNAM (4, 'NAMAATESTPROG')
(  126) READ (4, NAMAATESTPROG)
(  127) # 128 "aatestprog.F90"
(  128) IF ((NSMAX == 0) .OR. (NDGLG == 0)) THEN
(  129)   CALL ABOR1 ('DWARF: NSMAX AND NDGLG ARE REQUIRED')
(  130) ENDIF
(  131) # 132 "aatestprog.F90"
(  132) NPRGPNS = 0 
(  133) NPRGPEW = 0 
(  134) NPRTRW  = 0 
(  135) NPRTRV  = 0 
(  136) # 137 "aatestprog.F90"
(  137) CALL POSNAM (4, 'NAMPAR0')
(  138) READ (4, NAMPAR0)
(  139) # 140 "aatestprog.F90"
(  140) LUSEFLT   = NSMAX > 1280
(  141) LUSERPNM  = .NOT.LUSEFLT
(  142) LKEEPRPNM = .NOT.LUSEFLT
(  143) # 144 "aatestprog.F90"
(  144) CALL POSNAM (4, 'NAMTRANS')
(  145) READ (4, NAMTRANS)
(  146) # 147 "aatestprog.F90"
(  147) LEQ_REGIONS = .NOT. LELAM
(  148) LSPLIT      = .TRUE.
(  149) # 150 "aatestprog.F90"
(  150) CALL POSNAM (4, 'NAMPAR1')
(  151) READ (4, NAMPAR1)
(  152) # 153 "aatestprog.F90"
(  153) IF (LELAM) THEN
(  154)   NRGRI = NDLON
(  155) ELSE






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 80

(  156)   NRGRI = 0
(  157) ENDIF
(  158) # 159 "aatestprog.F90"
(  159) CALL POSNAM (4, 'NAMRGRI')
(  160) READ (4, NAMRGRI)
(  161) # 162 "aatestprog.F90"
(  162) CLOSE (4)
(  163) # 164 "aatestprog.F90"
(  164) ALLOCATE (NLOEN (NDGLG))
(  165) NLOEN (1:NDGLG) = NRGRI (1:NDGLG)
(  166) # 167 "aatestprog.F90"
(  167) IF (.NOT. LELAM) THEN
(  168)   IF (ANY (NLOEN (NDGLG/2+1:NDGLG) == 0)) THEN
(  169)     NLOEN (NDGLG/2+1:NDGLG) = NLOEN (NDGLG/2:1:-1)
(  170)   ENDIF
(  171)   IF (ANY (NLOEN (NDGLG/2:1:-1) /= NLOEN (NDGLG/2+1:NDGLG))) THEn
(  172)     CALL ABOR1 ('UNEXPECTED NLOEN')
(  173)   ENDIF
(  174) ENDIF
(  175) # 176 "aatestprog.F90"
(  176) IF (LLMPOFF) THEN
(  177)   MYPROC = 1
(  178)   NPROC  = 1
(  179) ELSE
(  180)   CALL MPL_INIT 
(  181)   MYPROC = MPL_MYRANK()
(  182)   NPROC  = MPL_NPROC ()
(  183) ENDIF
(  184) # 185 "aatestprog.F90"
(  185) ! GPU binding
(  186) # 187 "aatestprog.F90"
(  187) !CALL GPU_BIND (MYPROC-1, NPROC)
(  188) # 189 "aatestprog.F90"
(  189) IF (NPROC > 1 .AND. LLTESTHARMONICS) THEN
(  190)   CALL ABOR1 ('NPROC > 1 .AND. LLTESTHARMONICS')
(  191) ENDIF
(  192) # 193 "aatestprog.F90"
(  193) CALL SQUARE (NPROC, IB, IA)
(  194) # 195 "aatestprog.F90"
(  195) IF (NPRGPNS == 0 .AND. NPRGPEW == 0) THEN
(  196)   NPRGPNS = IA
(  197)   NPRGPEW = IB
(  198) ENDIF
(  199) # 200 "aatestprog.F90"
(  200) IF (NPRTRW == 0 .AND. NPRTRV == 0) THEN
(  201)   NPRTRW = IA
(  202)   NPRTRV = IB
(  203) ENDIF
(  204) # 205 "aatestprog.F90"
(  205) NBSETSP = MIN (NFLEVG+1, NPRTRV)
(  206) # 207 "aatestprog.F90"
(  207) IF (MYPROC == 1) THEN
(  208) # 209 "aatestprog.F90"
(  209)   WRITE (0, *) " NPROC = ", NPROC, " NTIME = ", NTIME, " LELAM = ", LELAM
(  210)   WRITE (0, *) " NFLDUA = ", NFLDUA, " NFLDSU = ", NFLDSU, " NFLEVG = ", NFLEVG
(  211)   WRITE (0, *) " NPRGPNS = ", NPRGPNS, " NPRGPEW = ", NPRGPEW
(  212)   WRITE (0, *) " NPRTRW = ", NPRTRW, " NPRTRV = ", NPRTRV
(  213)   WRITE (0, *) " LEQ_REGIONS = ", LEQ_REGIONS, " LSPLIT = ", LSPLIT






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 81

(  214)   WRITE (0, *) " NSMAX = ", NSMAX, " NDGLG = ", NDGLG
(  215) # 216 "aatestprog.F90"
(  216) ENDIF
(  217) # 218 "aatestprog.F90"
(  218) MYSETV = MOD (MYPROC-1, NPRTRV) + 1
(  219) MYSETW = (MYPROC-1) / NPRTRV + 1
(  220) # 222 "aatestprog.F90"
(  222) CALL SETUP_TRANS0 (KOUT=0, KERR=0, KPRINTLEV=NPRINTLEV, KMAX_RESOL=2,   &
(  223)                  & KPRGPNS=NPRGPNS, KPRGPEW=NPRGPEW, KPRTRW=NPRTRW,     &
(  224)                  & LDEQ_REGIONS=LEQ_REGIONS, LDMPOFF=LLMPOFF,           &
(  225)                  & LDALLOPERM=LLALLOPERM)
(  226) IF (LELAM) THEN
(  227)   CALL ESETUP_TRANS (KSMAX=NSMAX, KMSMAX=NMSMAX, KDGL=NDGLG, KDGUX=NDGLG, KLOEN=NLOEN, &
(  228)                    & LDSPLIT=LSPLIT, KFLEV=NFLEVG)
(  229)   CALL ETRANS_INQ (KSPEC2=NSPEC2, KGPTOT=NGPTOT, KSPEC2G=NSPEC2G, KGPTOTG=NGPTOTG)
(  230) ELSE
(  231)   CALL SETUP_TRANS (KSMAX=NSMAX, KDGL=NDGLG, KLOEN=NLOEN, LDSPLIT=LSPLIT, KFLEV=NFLEVG, &
(  232)                   & LDUSEFLT=LUSEFLT,LDUSERPNM=LUSERPNM, LDKEEPRPNM=LKEEPRPNM)
(  233)   CALL TRANS_INQ (KSPEC2=NSPEC2, KGPTOT=NGPTOT, KSPEC2G=NSPEC2G, KGPTOTG=NGPTOTG)
(  234) ENDIF
(  235) # 236 "aatestprog.F90"
(  236) IF (MYPROC == 1) THEN
(  237)   WRITE (0, *) " NGPTOTG = ", NGPTOTG, " NSPEC2G = ", NSPEC2G
(  238) ENDIF
(  239) # 240 "aatestprog.F90"
(  240) ALLOCATE (NBSETLEV (NFLEVG))
(  241) # 242 "aatestprog.F90"
(  242) DO ILEVG = 1, NFLEVG
(  243)   NBSETLEV (ILEVG) = MOD (ILEVG, NPRTRV) + 1
(  244) ENDDO
(  245) # 246 "aatestprog.F90"
(  246) NFLEV = COUNT (NBSETLEV == MYSETV)
(  247) # 248 "aatestprog.F90"
(  248) IFLDGPG = NFLDSU + NFLDUA * NFLEVG 
(  249) ALLOCATE (IVSET (IFLDGPG))
(  250) # 251 "aatestprog.F90"
(  251) DO IFLD = 1, NFLDSU
(  252)   IVSET (IFLD) = NBSETSP
(  253) ENDDO
(  254) # 255 "aatestprog.F90"
(  255) DO IFLD = 1, NFLDUA
(  256)   DO ILEVG = 1, NFLEVG
(  257)     IVSET (NFLDSU+ILEVG+(IFLD-1)*NFLEVG) = NBSETLEV (ILEVG)
(  258)   ENDDO
(  259) ENDDO
(  260) # 261 "aatestprog.F90"
(  261) IFLDSPL = COUNT (IVSET == MYSETV)
(  262) # 263 "aatestprog.F90"
(  263) ALLOCATE (ZSPBUFL (IFLDSPL, NSPEC2))
(  264) ALLOCATE (ZGPBUFL (NGPTOT, IFLDGPG, 1))
(  265) # 266 "aatestprog.F90"
(  266) CALL GENFIELD
(  267) # 269 "aatestprog.F90"
(  269) IF (LLCHECK) THEN
(  270)   CALL CHECK (LDDIFF=.FALSE.)
(  271) ENDIF
(  272) # 273 "aatestprog.F90"
(  273) IF (.NOT. LLNOWRITE) THEN






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 82

(  274)   CALL WRIFIELD ('AATESTPROG.0.fa')
(  275) ENDIF
(  276) # 277 "aatestprog.F90"
(  277) IF (.NOT. LLMPOFF) CALL MPL_BARRIER()
(  278) # 279 "aatestprog.F90"
(  279) LHOOK = LLHOOK
(  280) # 281 "aatestprog.F90"
(  281) IF (LHOOK) CALL DR_HOOK ('AATESTPROG',0,ZHOOK_HANDLE)
(  282) # 283 "aatestprog.F90"
(  283) IF (LLTESTHARMONICS) THEN
(  284)   CALL TESTHARMONICS
(  285) ELSE
(  286)   DO ITIME = 1, NTIME
(  287)     ZTSTEP = TIMEF()
(  288)     IF (LELAM) THEN
(  289)       IF (.NOT. LLNODIRTRANS) CALL EDIR_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  290)       IF (.NOT. LLNOINVTRANS) CALL EINV_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  291)     ELSE
(  292)       IF (.NOT. LLNODIRTRANS) CALL DIR_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  293)       IF (.NOT. LLNOINVTRANS) CALL INV_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  294)     ENDIF
(  295)   
(  296)     IF(MYPROC == 1) THEN
(  297)       ZTSTEP=(TIMEF()-ZTSTEP)
(  298)       WRITE(*,'(" time step ",I6," took", F8.2)') ITIME, ZTSTEP
(  299)     ENDIF
(  300)   ENDDO
(  301) ENDIF
(  302) # 303 "aatestprog.F90"
(  303) CALL FLUSH (0)
(  304) # 305 "aatestprog.F90"
(  305) IF (LELAM) THEN
(  306)   CALL ETRANS_END
(  307) ELSE
(  308)   CALL TRANS_END
(  309) ENDIF
(  310) # 311 "aatestprog.F90"
(  311) 999 CONTINUE
(  312) # 313 "aatestprog.F90"
(  313) IF (.NOT. LLMPOFF) CALL MPL_BARRIER
(  314) # 315 "aatestprog.F90"
(  315) IF (LHOOK) CALL DR_HOOK ('AATESTPROG',1,ZHOOK_HANDLE)
(  316) # 317 "aatestprog.F90"
(  317) IF (.NOT. LLNOWRITE) THEN
(  318)   CALL WRIFIELD ('AATESTPROG.1.fa')
(  319) ENDIF
(  320) # 321 "aatestprog.F90"
(  321) IF (LLCHECK) THEN
(  322)   CALL CHECK (LDDIFF=.FALSE.)
(  323)   CALL CHECK (LDDIFF=.TRUE.)
(  324) ENDIF
(  325) # 326 "aatestprog.F90"
(  326) IF (.NOT. LLMPOFF) CALL MPL_END
(  327) # 328 "aatestprog.F90"
(  328) IF (MYPROC == 1) WRITE (0, *) " --------- END --------- "
(  329) # 330 "aatestprog.F90"
(  330) CALL FLUSH (0)
(  331) # 332 "aatestprog.F90"






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 83

(  332) CONTAINS
(  333) # 334 "aatestprog.F90"
(  334) SUBROUTINE TESTHARMONICS
(  335) # 336 "aatestprog.F90"
(  336) INTEGER (KIND=JPIM) :: INHARM
(  337) CHARACTER (LEN=32) :: CLFILE
(  338) # 339 "aatestprog.F90"
(  339) DO INHARM = 1, NSPEC2G
(  340) # 341 "aatestprog.F90"
(  341)   WRITE (CLFILE, '(I6.6)') INHARM
(  342) # 343 "aatestprog.F90"
(  343)   ZSPBUFL = 0._JPRB
(  344)   ZSPBUFL (1, INHARM) = 1._JPRB
(  345)   ZGPBUFL = 999._JPRB
(  346) # 347 "aatestprog.F90"
(  347)   CALL EINV_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  348)   
(  349) ! OPEN (77, FILE=TRIM (CLFILE)//'.gp.dat')
(  350) ! WRITE (77, *) ZGPBUFL (:, 1, 1)
(  351) ! CLOSE (77)
(  352) # 353 "aatestprog.F90"
(  353)   ZSPBUFL = 999._JPRB
(  354) # 355 "aatestprog.F90"
(  355)   CALL EDIR_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL, KVSETSC=IVSET)
(  356) # 357 "aatestprog.F90"
(  357) ! OPEN (77, FILE=TRIM (CLFILE)//'.sp.dat')
(  358) ! WRITE (77, *) ZSPBUFL (1, :)
(  359) ! CLOSE (77)
(  360) # 361 "aatestprog.F90"
(  361)   WHERE (ABS (ZSPBUFL) < 1E-15)
(  362)     ZSPBUFL = 0._JPRB
(  363)   ENDWHERE
(  364) # 365 "aatestprog.F90"
(  365)   WHERE (ABS (ZSPBUFL - 1._JPRB) < 1E-15)
(  366)     ZSPBUFL = 1._JPRB
(  367)   ENDWHERE
(  368) # 369 "aatestprog.F90"
(  369)   WRITE (88, '(I6," ",I6," ",I6," ",I6," ",I6)') INHARM, &
(  370)        & COUNT (ZSPBUFL (1, :) == 0._JPRB), COUNT (ZSPBUFL (1, :) == 1._JPRB), &
(  371)        & COUNT ((ZSPBUFL (1, :) /= 1._JPRB) .AND. (ZSPBUFL (1, :) /= 0._JPRB)), &
(  372)        & NSPEC2G
(  373)  
(  374) # 375 "aatestprog.F90"
(  375) ENDDO
(  376) # 377 "aatestprog.F90"
(  377) END SUBROUTINE
(  378) # 379 "aatestprog.F90"
(  379) SUBROUTINE SQUARE (KN, KA, KB)
(  380) # 381 "aatestprog.F90"
(  381) INTEGER (KIND=JPIM) :: KN, KA, KB
(  382) # 383 "aatestprog.F90"
(  383) KB = INT (SQRT (REAL (KN))) + 1
(  384) # 385 "aatestprog.F90"
(  385) DO
(  386)   KA = KN / KB
(  387)   IF (KA * KB == KN) EXIT
(  388)   KB = KB - 1
(  389) ENDDO






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 84

(  390) # 391 "aatestprog.F90"
(  391) END SUBROUTINE SQUARE
(  392) # 393 "aatestprog.F90"
(  393) SUBROUTINE POSNAM (KULNAM,CDNAML)
(  394) # 395 "aatestprog.F90"
(  395) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  396) USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
(  397) # 398 "aatestprog.F90"
(  398) IMPLICIT NONE
(  399) # 400 "aatestprog.F90"
(  400) INTEGER(KIND=JPIM),INTENT(IN)    :: KULNAM 
(  401) CHARACTER(LEN=*)  ,INTENT(IN)    :: CDNAML 
(  402) # 404 "aatestprog.F90"
(  404) # 1 ".D[12]/abor1.intfb.h"
(    1) INTERFACE
(    2) # 3 ".D[12]/abor1.intfb.h"
(    3) SUBROUTINE ABOR1(CDTEXT)
(    4) CHARACTER(LEN=*), INTENT(IN) :: CDTEXT
(    5) END SUBROUTINE ABOR1
(    6) # 7 ".D[12]/abor1.intfb.h"
(    7) SUBROUTINE ABOR1FL(CDFILE, KLINENUM, CDTEXT)
(    8) USE PARKIND1  ,ONLY : JPIM
(    9) CHARACTER(LEN=*), INTENT(IN) :: CDFILE,CDTEXT
(   10) INTEGER(KIND=JPIM), INTENT(IN) :: KLINENUM
(   11) END SUBROUTINE ABOR1FL
(   12) # 13 ".D[12]/abor1.intfb.h"
(   13) SUBROUTINE ABOR1_EXCEPTION_HANDLER()
(   14) END SUBROUTINE ABOR1_EXCEPTION_HANDLER
(   15) # 16 ".D[12]/abor1.intfb.h"
(   16) END INTERFACE
(   17) # 405 "aatestprog.F90"
(  405) # 407 "aatestprog.F90"
(  407) CHARACTER (LEN = 40) ::  CLINE
(  408) CHARACTER (LEN =  1) ::  CLTEST
(  409) # 410 "aatestprog.F90"
(  410) INTEGER(KIND=JPIM) :: ILEN, IND1, ISTATUS, ISCAN
(  411) REAL(KIND=JPRB)    :: ZHOOK_HANDLE
(  412) # 413 "aatestprog.F90"
(  413) IF (LHOOK) CALL DR_HOOK('POSNAM',0,ZHOOK_HANDLE)
(  414) # 415 "aatestprog.F90"
(  415) CLINE='                                        '
(  416) REWIND(KULNAM)
(  417) ILEN=LEN(CDNAML)
(  418) ISTATUS=0
(  419) ISCAN=0
(  420) DO WHILE (ISTATUS==0 .AND. ISCAN==0)
(  421)   READ(KULNAM,'(A)',IOSTAT=ISTATUS) CLINE
(  422)   SELECT CASE (ISTATUS)
(  423)   CASE (:-1)
(  424)     CALL ABOR1 ('POSNAM: CANNOT FIND '//TRIM (CDNAML))
(  425)   CASE (0)
(  426)     IF (INDEX(CLINE(1:10),'&') == 0) THEN
(  427)       ISCAN=0
(  428)     ELSE
(  429)       IND1=INDEX(CLINE,'&'//CDNAML)
(  430)       IF (IND1 == 0) THEN
(  431)         ISCAN=0
(  432)       ELSE






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 85

(  433)         CLTEST=CLINE(IND1+ILEN+1:IND1+ILEN+1)
(  434)         IF (   (LGE(CLTEST,'0').AND.LLE(CLTEST,'9')) &
(  435)          & .OR.(LGE(CLTEST,'A').AND.LLE(CLTEST,'Z')) ) THEN
(  436)           ISCAN=0
(  437)         ELSE
(  438)           ISCAN=1
(  439)         ENDIF
(  440)       ENDIF
(  441)     ENDIF
(  442)   CASE (1:)
(  443)     CALL ABOR1 ('POSNAM: AN ERROR HAPPENED WHILE READING THE NAMELIST')
(  444)   END SELECT
(  445) ENDDO
(  446) BACKSPACE(KULNAM)
(  447) # 448 "aatestprog.F90"
(  448) IF (LHOOK) CALL DR_HOOK('POSNAM',1,ZHOOK_HANDLE)
(  449) END SUBROUTINE POSNAM
(  450) # 451 "aatestprog.F90"
(  451) SUBROUTINE WRIFIELD (CDFILE)
(  452) # 453 "aatestprog.F90"
(  453) CHARACTER (LEN=*), INTENT (IN) :: CDFILE
(  454) INTEGER (KIND=JPIM) :: ITO (IFLDGPG), JFLD
(  455) CHARACTER (LEN=16) :: CLPREF, CLSUFF
(  456) # 457 "aatestprog.F90"
(  457) ITO = 1
(  458) # 459 "aatestprog.F90"
(  459) IF (MYPROC == 1) THEN
(  460)   ALLOCATE (ZGPBUFG (NGPTOTG, IFLDGPG))
(  461) # 462 "aatestprog.F90"
(  462)   IF (LELAM) THEN
(  463)     CALL EGATH_GRID (PGPG=ZGPBUFG, KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
(  464)   ELSE
(  465)     CALL GATH_GRID (PGPG=ZGPBUFG, KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
(  466)   ENDIF
(  467) # 468 "aatestprog.F90"
(  468)   CALL SYSTEM ('rm -f '//TRIM (CDFILE))
(  469) # 470 "aatestprog.F90"
(  470)   DO JFLD = 1, IFLDGPG
(  471)     CLPREF = 'SURF'
(  472)     WRITE (CLSUFF, '("FFFF.",I4.4)') JFLD
(  473)     CALL WFA (ZGPBUFG (:, JFLD), CDFILE, CLPREF, CLSUFF)
(  474)   ENDDO
(  475) # 476 "aatestprog.F90"
(  476)   DEALLOCATE (ZGPBUFG)
(  477) ELSE
(  478)   IF (LELAM) THEN
(  479)     CALL EGATH_GRID (KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
(  480)   ELSE
(  481)     CALL GATH_GRID (KFGATHG=IFLDGPG, KTO=ITO, PGP=ZGPBUFL (:,:,:))
(  482)   ENDIF
(  483) ENDIF
(  484) # 485 "aatestprog.F90"
(  485) END SUBROUTINE
(  486) # 487 "aatestprog.F90"
(  487) SUBROUTINE WFA (PGLO, CDFILE, CDPREF, CDSUFF)
(  488) # 489 "aatestprog.F90"
(  489) REAL (KIND=JPRB),  INTENT (IN) :: PGLO (:)
(  490) CHARACTER (LEN=*), INTENT (IN) :: CDFILE, CDPREF, CDSUFF






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 86

(  491) # 492 "aatestprog.F90"
(  492) REAL (KIND=JPRB) :: ZMU (NDGLG)
(  493) # 494 "aatestprog.F90"
(  494) CHARACTER (LEN=3) :: CLNOMC 
(  495) REAL (KIND=JPRB) :: ZAHYBR (2), ZBHYBR (2), ZSLAPO, ZCLOPO, ZSLOPO, ZCODIL, ZREFER
(  496) INTEGER (KIND=JPIM) :: INIVER, ITYPTR, ITRONC, INLATI, INXLON
(  497) INTEGER (KIND=JPIM) :: NLOENG (NDGLG), INOZPA (NDGLG)
(  498) INTEGER (KIND=JPIM) :: INBARP, INBARI, ILUN, IREP
(  499) INTEGER (KIND=JPIM) :: INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5
(  500) INTEGER (KIND=JPIM) :: IDATEF (11), ILCHAM
(  501) CHARACTER (LEN=16)  :: CLSTATUS
(  502) LOGICAL :: LLEXIST
(  503) # 504 "aatestprog.F90"
(  504) INQUIRE (FILE=TRIM (CDFILE), EXIST=LLEXIST)
(  505) # 506 "aatestprog.F90"
(  506) IF (LLEXIST) THEN
(  507)   CLSTATUS = 'OLD'
(  508)   IF (LELAM) THEN
(  509)     CLNOMC = 'ALD'
(  510)   ELSE
(  511)     CLNOMC = 'ARP'
(  512)   ENDIF
(  513) ELSE
(  514)   CLSTATUS = 'NEW'
(  515) IF (LELAM) THEN
(  516) BLOCK
(  517)   INTEGER (KIND=JPIM) :: INLOPA (8)
(  518)   INTEGER (KIND=JPIM) :: NX, NY, NUX, NUY
(  519)   REAL (KIND=JPRB) :: DXINMETRES, DYINMETRES
(  520)   REAL (KIND=JPRB) :: ZSINLA (18)
(  521) # 522 "aatestprog.F90"
(  522)   REAL (KIND=JPRB), PARAMETER :: LADINDEGREES    = 46.2_JPRB
(  523)   REAL (KIND=JPRB), PARAMETER :: LATIN1INDEGREES = 46.2_JPRB
(  524)   REAL (KIND=JPRB), PARAMETER :: LATIN2INDEGREES = 46.2_JPRB
(  525)   REAL (KIND=JPRB), PARAMETER :: LOVINDEGREES    =  2.0_JPRB
(  526) # 527 "aatestprog.F90"
(  527)   CLNOMC = 'ALD'
(  528)   NX = NDLON
(  529)   NY = NDGLG
(  530) # 531 "aatestprog.F90"
(  531)   ! Round dx to 100m
(  532)   DXINMETRES = 2000.E3_JPRB / REAL (NX - 1, JPRB)
(  533)   DXINMETRES = 100._JPRB * NINT (DXINMETRES / 100._JPRB) 
(  534)   DYINMETRES = DXINMETRES
(  535) # 536 "aatestprog.F90"
(  536)   NUX = NX - 1
(  537)   NUY = NY - 1
(  538) # 539 "aatestprog.F90"
(  539)   INLATI = NY
(  540)   INXLON = NX
(  541)   ZSLAPO = 0._JPRB
(  542)   ZCLOPO = 0._JPRB
(  543)   ZSLOPO = 0._JPRB
(  544)   ZCODIL = 0._JPRB
(  545)   ZREFER = 0._JPRB
(  546)   INIVER = 1_JPIM
(  547)   ZAHYBR = 0._JPRB
(  548)   ZBHYBR = 0._JPRB 






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 87

(  549)   INLOPA = [10_JPIM, 1_JPIM, 1_JPIM, NUX+1, 1_JPIM, NUY+1, 8_JPIM, 8_JPIM]
(  550)   ITRONC = +INLATI / 2 - 1 
(  551)   ITYPTR = -INXLON / 2 + 1 
(  552)   
(  553)   ZSINLA = [-1._JPRB, SIN (DEG2RAD * LADINDEGREES), DEG2RAD * LOVINDEGREES, DEG2RAD * LADINDEGREES, &
(  554)          &  DEG2RAD * LOVINDEGREES, DEG2RAD * LADINDEGREES, DXINMETRES, DYINMETRES, &
(  555)          &  INXLON * DXINMETRES, INLATI * DYINMETRES, 0._JPRB, 0._JPRB, 0._JPRB, &
(  556)          &  0._JPRB, 0._JPRB, 0._JPRB, 0._JPRB, 0._JPRB ]
(  557)   
(  558)   CALL FACADE (CLNOMC, ITYPTR, ZSLAPO, ZCLOPO, ZSLOPO, &
(  559)   &            ZCODIL, ITRONC, INLATI, INXLON, INLOPA, &
(  560)   &            INOZPA, ZSINLA, INIVER, ZREFER, ZAHYBR, &
(  561)   &            ZBHYBR, .FALSE.)
(  562) # 563 "aatestprog.F90"
(  563) ENDBLOCK
(  564) ELSE
(  565) BLOCK
(  566)   REAL (KIND=JPRB) :: ZCENTRE (2)
(  567) # 568 "aatestprog.F90"
(  568)   CLNOMC = 'ARP'
(  569) # 570 "aatestprog.F90"
(  570)   CALL TRANS_INQ (PMU=ZMU)
(  571)   
(  572)   ZCENTRE = [0._JPRB, 90._JPRB]
(  573)   ZCODIL = 1._JPRB
(  574)   
(  575)   INIVER = 1_JPIM
(  576)   ZAHYBR = 0._JPRB
(  577)   ZBHYBR = 0._JPRB
(  578)   ITYPTR = 2_JPIM
(  579)   
(  580)   NLOENG = NLOEN
(  581)   
(  582)   ZSLAPO = SIN (ZCENTRE (2) * DEG2RAD)
(  583)   ZCLOPO = COS (ZCENTRE (1) * DEG2RAD)
(  584)   ZSLOPO = SIN (ZCENTRE (1) * DEG2RAD)
(  585)   INLATI = NDGLG
(  586)   INXLON = MAXVAL (NLOENG)
(  587)   ITRONC = INXLON / 3
(  588)   INOZPA = MIN (ITRONC, NLOENG/2_JPIM-1_JPIM)
(  589)   ZREFER = 1._JPRB
(  590)   
(  591)   CALL FACADE (CLNOMC, ITYPTR, ZSLAPO, ZCLOPO, ZSLOPO, &
(  592)   &            ZCODIL, ITRONC, INLATI, INXLON, NLOENG, &
(  593)   &            INOZPA, ZMU,    INIVER, ZREFER, ZAHYBR, &
(  594)   &            ZBHYBR, .FALSE.)
(  595) # 596 "aatestprog.F90"
(  596) ENDBLOCK
(  597) ENDIF
(  598) ENDIF
(  599)  
(  600) # 601 "aatestprog.F90"
(  601) INBARP = 0
(  602) INBARI = 0
(  603) ILUN = 77
(  604) CALL FAITOU (IREP, ILUN, .TRUE., TRIM (CDFILE), CLSTATUS, .TRUE., &
(  605)            & .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)
(  606) # 607 "aatestprog.F90"






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 88

(  607) IDATEF = [1990,  2, 15, 12,  0,   1,  0, 24,   1, 0, 0]
(  608) CALL FANDAR (IREP, ILUN, IDATEF)
(  609) # 610 "aatestprog.F90"
(  610) CALL FATCHA (IREP, CLNOMC, .FALSE., ILCHAM)
(  611) # 612 "aatestprog.F90"
(  612) CALL FAVEUR (IREP, ILUN, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)
(  613) INGRIB = 123_JPIM
(  614) CALL FAGOTE (IREP, ILUN, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)
(  615) # 616 "aatestprog.F90"
(  616) CALL FAIENC (IREP, ILUN, CDPREF, 0, CDSUFF, PGLO, .FALSE.)
(  617) # 618 "aatestprog.F90"
(  618) CALL FAIRME (IREP, ILUN, 'KEEP')
(  619) # 620 "aatestprog.F90"
(  620) END SUBROUTINE
(  621) # 622 "aatestprog.F90"
(  622) SUBROUTINE CHECK (LDDIFF)
(  623) # 624 "aatestprog.F90"
(  624) LOGICAL, INTENT (IN) :: LDDIFF
(  625) # 626 "aatestprog.F90"
(  626) ! Save result in ZGPBUFL1
(  627) # 628 "aatestprog.F90"
(  628) REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFL1 (:,:,:) 
(  629) REAL (KIND=JPRB),    ALLOCATABLE :: ZGPBUFG1 (:,:) 
(  630) INTEGER (KIND=JPIM) :: JFLD, ITO (1)
(  631) REAL (KIND=JPRB) :: ZDIFF2 (IFLDGPG)
(  632) # 633 "aatestprog.F90"
(  633) ALLOCATE (ZGPBUFL1 (NGPTOT, IFLDGPG, 1)) 
(  634) # 635 "aatestprog.F90"
(  635) ZGPBUFL1 = ZGPBUFL
(  636) # 637 "aatestprog.F90"
(  637) ! Recreate original field
(  638) # 640 "aatestprog.F90"
(  640) IF (LDDIFF) THEN
(  641)   CALL GENFIELD
(  642)   ZGPBUFL1 = ZGPBUFL1 - ZGPBUFL
(  643) ENDIF
(  644) # 645 "aatestprog.F90"
(  645) IF (MYPROC == 1) THEN
(  646)   IF (LDDIFF) THEN
(  647)     WRITE (100, *) "                  ------------- DIFF ------------- "
(  648)   ELSE
(  649)     WRITE (100, *) "                  ------------- STAT ------------- "
(  650)   ENDIF
(  651) ENDIF
(  652) # 653 "aatestprog.F90"
(  653) ITO = 1
(  654) # 655 "aatestprog.F90"
(  655) DO JFLD = 1, IFLDGPG
(  656) # 657 "aatestprog.F90"
(  657)   IF (MYPROC == 1) THEN
(  658)     ALLOCATE (ZGPBUFG1 (NGPTOTG, 1))
(  659)     IF (LELAM) THEN
(  660)       CALL EGATH_GRID (PGPG=ZGPBUFG1, KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))
(  661)     ELSE
(  662)       CALL GATH_GRID (PGPG=ZGPBUFG1, KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))
(  663)     ENDIF
(  664)     WRITE (100, '(" FIELD ",I6," L2 =",E16.8," L1 = ",E16.8," MEAN =",E16.8)') & 
(  665)          & JFLD, SQRT (SUM (ZGPBUFG1 * ZGPBUFG1) / REAL (NGPTOTG, JPRB)), &






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 89

(  666)          & SUM (ABS (ZGPBUFG1)) / REAL (NGPTOTG, JPRB), SUM (ZGPBUFG1)
(  667)     DEALLOCATE (ZGPBUFG1)
(  668)   ELSE
(  669)     IF (LELAM) THEN
(  670)       CALL EGATH_GRID (KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))
(  671)     ELSE
(  672)       CALL GATH_GRID (KFGATHG=1, KTO=ITO, PGP=ZGPBUFL1 (:,JFLD:JFLD,:))
(  673)     ENDIF
(  674)   ENDIF
(  675) # 676 "aatestprog.F90"
(  676) ENDDO
(  677) # 678 "aatestprog.F90"
(  678) END SUBROUTINE
(  679) # 680 "aatestprog.F90"
(  680) SUBROUTINE GENFIELD
(  681) # 682 "aatestprog.F90"
(  682) IF (MYPROC == 1) THEN
(  683)   ALLOCATE (ZGPBUFG (NGPTOTG, 1))
(  684) # 685 "aatestprog.F90"
(  685)   IF (CLFIELD /= '') THEN
(  686)     OPEN (77, FILE=TRIM (CLFIELD), FORM='UNFORMATTED', STATUS='OLD')
(  687)     READ (77) ZGPBUFG (:, 1)
(  688)     CLOSE (77)
(  689)   ELSE
(  690)   BLOCK
(  691)     REAL (KIND=JPRB) :: ZLON, ZLAT, ZVAL, ZX, ZY
(  692)     INTEGER (KIND=JPIM) :: JLAT, JLON, JGLO
(  693) # 694 "aatestprog.F90"
(  694)     JGLO = 1
(  695) # 696 "aatestprog.F90"
(  696)     DO JLAT = 1, NDGLG
(  697)       DO JLON = 1, NLOEN (JLAT)
(  698)        
(  699)         IF (LELAM) THEN
(  700)           ZX = REAL (JLON-1, JPRB) / REAL (NDLON, JPRB)
(  701)           ZY = REAL (JLAT-1, JPRB) / REAL (NDLON, JPRB)
(  702)           ZVAL = ZX * (1._JPRB - ZX) * ZY * (1._JPRB - ZY) * 4._JPRB + 0.5
(  703)         ELSE
(  704)           ZLAT = + RPI * (0.5_JPRB - REAL (JLAT, JPRB) / REAL (NDGLG+1, JPRB))
(  705)           ZLON = 2 * RPI * REAL (JLON-1, JPRB) / REAL (NLOEN (JLAT))
(  706)           ZVAL = COS (ZLAT) * SIN (ZLON)
(  707)         ENDIF
(  708)         ZGPBUFG (JGLO, 1) = ZVAL
(  709)         JGLO = JGLO + 1
(  710)       ENDDO
(  711)     ENDDO
(  712)   ENDBLOCK
(  713)   ENDIF
(  714) # 715 "aatestprog.F90"
(  715)   IF (LELAM) THEN
(  716)     CALL EDIST_GRID (PGPG=ZGPBUFG, KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
(  717)   ELSE
(  718)     CALL DIST_GRID (PGPG=ZGPBUFG, KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
(  719)   ENDIF
(  720) # 721 "aatestprog.F90"
(  721)   DEALLOCATE (ZGPBUFG)
(  722) # 723 "aatestprog.F90"
(  723) ELSE






NVFORTRAN (Version    20.11)          12/07/2021  15:28:47      page 90

(  724)   IF (LELAM) THEN
(  725)     CALL EDIST_GRID (KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
(  726)   ELSE
(  727)     CALL DIST_GRID (KFDISTG=1_JPIM, KFROM=[1_JPIM], PGP=ZGPBUFL (:,1:1,:))
(  728)   ENDIF
(  729) ENDIF
(  730) # 731 "aatestprog.F90"
(  731) DO IFLD = 2, IFLDGPG
(  732)   ZGPBUFL (:, IFLD, 1) = ZGPBUFL (:, 1, 1) * REAL (IFLD, JPRB)
(  733) ENDDO
(  734) # 736 "aatestprog.F90"
(  736) END SUBROUTINE
(  737) # 738 "aatestprog.F90"
(  738) END PROGRAM TEST
